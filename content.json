{"pages":[{"title":"about","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/about/index.html"},{"title":"categories","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/categories/index.html"},{"title":"tags","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/tags/index.html"},{"title":"","text":"title: 404 date: 2018-09-30 17:25:30 type: \"404\" layout: \"404\" description: \"Oops～，我崩溃了！找不到你想要的页面 :(\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/404.html"},{"title":"contact","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/contact/index.html"},{"title":"friends","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/friends/index.html"}],"posts":[{"title":"1-1 安装bitnami虚拟机","text":"[toc] 第 1 步：启动 Bitnami WordPress 虚拟机 下载连接:https://bitnami.com/stack/wordpress/virtual-machine 使用虚拟机打开连接 现在，您可以通过启动 Web 浏览器并浏览虚拟机的 IP 地址来访问 WordPress。您应该会看到博客的头版，并包含一个示例帖子，如下所示： http://192.168.2.139/ 第 2 步：登录并使用 WordPress 开始要登录到 WordPress 仪表板，请按照以下步骤操作： 浏览到 WordPress 仪表板，通常在 URL http://192.168.2.139/wp-admin。 查看用户名和密码 sudo cat /home/bitnami/bitnami_credentials 设置中文显示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/bitnami-xu-ni-ji/1-1-an-zhuang-bitnami-xu-ni-ji/"},{"title":"1-1-安装","text":"Docker入门安装简介：作用和虚拟机相似，可以一键部署linux mysql nginx。。。 docker 虚拟机 相同点 1. 都可在不同的主机之间迁移 2. 都具备 root 权限 3. 都可以远程控制 4. 都有备份、回滚操作 操作系统 在性能上有优势，可以轻易的运行多个操作系统 可以安装任何系统，但是性能不及容器 原理 和宿主机共享内核，所有容器运行在容器引擎之上，容器并非一个完整的操作系统，\b所有容器共享操作系统，在进程级进行隔离 每一个虚拟机都建立在虚拟的硬件之上，提供指令级的虚拟，具备一个完整的操作系统 优点 高效、集中。一个硬件\b节点可以运行数以百计的的容器，非常节省资源，QoS 会尽量满足，但不保证一定满足。内核\b由提供者升级，服务由服务提供者管理 对操作系统具有绝对权限，对系统版本和系统升级具有完全的管理权限。具有一整套的的资源：CPU、RAM 和磁盘。QoS 是有保证的，每一个虚拟机就像一个真实的物理机一样，可以实现不同的操作系统运行在同一物理节点上。 资源管理 弹性资源分配：资源可以在没有关闭容器的情况下添加，数据卷也无需重新分配大小 虚拟机需要重启，虚拟机里边的操作系统需要处理新加入的资源，如磁盘等，都需要重新分区。 远程管理 根据操作系统的不同，可以通过 shell 或者远程桌面进行 远程控制由虚拟化平台提供，可以在\b虚拟机启动之前连接 缺点 对内核没有控制权限，只有容器的提供者具备升级权限。只有一个内核运行在物理节点上，几乎不能实现不同的操作系统混合。容器提供者一般仅提供少数的几个操作系统 每一台虚拟机都具有更大的负载，耗费更多的资源，用户需要全权维护和管理。一台物理机上能够运行的虚拟机非常有限 配置 快速，基本上是一键配置 配置时间长 启动时间 秒级 分钟级 硬盘使用 MB GB 性能 接近原生态 弱于原生态 系统支持数量 \b单机支持上千个 一般不多于几十个 核心组件 镜像 images 静态模板，保存保存容器需要的环境，和应用执行代码，可以将镜像看作容器的代码，当代码运行起来就成了容器 容器 一个运行的环境，镜像的运行状态， 库 特定用户存储镜像的目录，一个用户可以建立多个用户来保存自己的镜像 安装命令# 首先安装 Docker yum -y install docker # 然后启动 Docker 服务 service docker start # 测试安装是否成功 docker -v document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/docker-xue-xi/1-1-an-zhuang/"},{"title":"1-1 简介","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/gitbook-xue-xi/1-1-jian-jie/"},{"title":"Untitled","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/untitled/"},{"title":"1-1简介","text":"简介github pages + Hexo 创建个人博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/chuang-jian-ge-ren-bo-ke/1-1-jian-jie/"},{"title":"1-1 简介","text":"简介地址:https://pages.github.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/chuang-jian-ge-ren-bo-ke/github-pages/1-1-jian-jie/"},{"title":"1-1 简介","text":"[TOC] 中文文档 什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) Git 安装 Hexo npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 新建完成后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/chuang-jian-ge-ren-bo-ke/hexo/1-1-jian-jie/"},{"title":"3-1 hexo与md文件格式的冲突","text":"将图片地址改为github引用,不然md原生格式无法预览需要标准编写格式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/chuang-jian-ge-ren-bo-ke/hexo/3-1-hexo-yu-md-wen-jian-ge-shi-de-chong-tu/"},{"title":"1-1 简单使用","text":"作用 免费的图片服务器,用存放图片,方便引用地址 条件 GitHub创建一个仓库 在设置里GitHub获取token 下载PicGo 设置图床 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/chuang-jian-tu-pian-di-zhi-chuang-ku/1-1-jian-dan-shi-yong/"},{"title":"1-1 Git 设置和配置","text":"[toc] 简介官方文档：https://git-scm.com/docs git [--version] [--help] [-C ] [-c =] [--exec-path[=]] [--html-path] [--man-path] [--info-path] [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare] [--git-dir=] [--work-tree=] [--namespace=] [--super-prefix=] [] Git 是一个快速的、可扩展的、具有异常丰富的命令集的分散式版本控制，它既提供了高级操作，也提供了对内部的完全访问。 安装# linux系统 sudo apt-get install git yum install git # windos 去官网下载安装包 配置git 打开git终端,配置用户名和邮箱,必须 git config --global user.name \"kujin\" git config --global user.email \"kujin@qq.com\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/git-xue-xi/1-1-git-she-zhi-he-pei-zhi/"},{"title":"2-1 Git忽略文件","text":"[toc] 1.忽略文件git会一行行读取文件内容,被忽略的文件不会被上传 固定文件名: .gitignore*.iml .gradle /locak.properties /build 2.查看修改内容git status 3.查看提交记录git log document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/git-xue-xi/2-1-git-hu-lue-wen-jian/"},{"title":"2-2 Git获取和创建项目","text":"简介git init 创建一个空的 Git 存储库或重新初始化现有存储库 git init [-q | --quiet] [--bare] [--template=&lt;template_directory>] [--separate-git-dir &lt;git dir>] [--object-format=&lt;format>] [-b &lt;branch-name> | --initial-branch=&lt;branch-name>] [--shared[=&lt;permissions>]] [directory] 选择 命令 描述 -q 只打印错误和警告消息; 所有其他输出将被禁止 -bare 创建一个裸库。如果没有设置环境，则将其设置为当前的工作目录 -b 新创建的存储库中为初始分支使用指定的名称。如果没有指定，则退回到默认名称: master Git Clone 将存储库克隆到一个新目录中 git clone [--template=&lt;template_directory&gt;] [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror] [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;] [--dissociate] [--separate-git-dir &lt;git dir&gt;] [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags] [--recurse-submodules[=&lt;pathspec&gt;]] [--[no-]shallow-submodules] [--[no-]remote-submodules] [--jobs &lt;n&gt;] [--sparse] [--filter=&lt;filter&gt;] [--] &lt;repository&gt; [&lt;directory&gt;] 克隆一个存储库到一个新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支(使用 git branch – remotes 可见) ，并创建和检出从克隆的存储库的当前活动分支中分支出来的初始分支。 选项 命令 描述 -b - b &lt; 姓名 &gt; 不要将新创建的 HEAD 指向克隆存储库的 HEAD 所指向的分支，而是指向 &lt; name &gt; branch。在非裸存储库中，这是要签出的分支。– branch 还可以获取标记，并在结果存储库中的那个提交处分离 HEAD。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/git-xue-xi/2-2-git-huo-qu-he-chuang-jian-xiang-mu/"},{"title":"3-1 关键命令","text":"命令 解释 git init 进入一个空的目录，命令行 git init 进行初始化！ git clone ***.git 克隆一个git地址 后面添加一个git地址，git会自动下载到本地 git add . 添加需要提交的代码 可以是具体的文件名 . 代表全部 git commit -m “提交描述” 提交文件，但没有上传到服务器 添加 -m “提交描述” git push 上传到服务器 git pull 下载到本地 git branch testing 创建分支testing git checkout testing 切换到新创建的 testing 分支 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/git-xue-xi/3-1-guan-jian-ming-ling/"},{"title":"3-2 添加","text":"git-add - 将文件内容添加到索引git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize] [--chmod=(+|-)x] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [--] [&lt;pathspec&gt;…] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/git-xue-xi/3-2-tian-jia/"},{"title":"idea工具的使用","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/idea-gong-ju-de-shi-yong/"},{"title":"利用IDEA明明导入了包却显示缺少保留相关类","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/li-yong-idea-ming-ming-dao-ru-liao-bao-que-xian-shi-que-shao-bao-liu-xiang-guan-lei/"},{"title":"IDEA中Tomcat日志乱码","text":"&nbsp; 问题，在idea中出现乱码问题，以前没有的，好像在设置系统代码为utf8之后就出现了，于是尝试了一系列办法，希望这些办法对您有帮助。 先看一下乱码的样式。 设置办法 1、在tomcat Server中设置 VM options , 值为&nbsp;-Dfile.encoding=UTF-8 ，可惜没生效 1 &nbsp; 2、在setting中的 File encodings 中设置编码格式，后来发现这是设置页面编码格式的，所以也没生效，不过遇到相关问题的朋友也不防照此设置下。 3、在java Complier中设置Additional command line parameters的值，-encoding=UTF-8，很可惜还没生效 4、在bin中设置idea.exe.vmoptions和idea64.exe.vmoptions中的参数，同时增加-Dfile.encoding=UTF-8，据说有些人保存后重启就可以了，但到我这边还是没生效。 5、在tomcat \\bin目录下的catalina.bat文件中加入&nbsp;-Dfile.encoding=UTF-8，可是还不生效，有些抓狂了... 6、在 tomcat / conf 目录下，设置&nbsp;logging.properties ，增加参数&nbsp;&nbsp;java.util.logging.ConsoleHandler.encoding = GBK，重启后终于可以了，总算松了口气。 终于，正常显示了...... 7、另外在服务器上tomcat还需要设置&nbsp;server.xml中的参数，以防页面出现乱码 &lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\"&nbsp; redirectPort=\"8443\"&nbsp; URIEncoding=\"UTF-8\" /&gt; &lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" URIEncoding=\"UTF-8\" /&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/idea-zhong-tomcat-ri-zhi-luan-ma/"},{"title":"idea报java版本错误解决方法","text":"&nbsp; &nbsp; &nbsp; &nbsp;在Intellij idea中新建了一个Maven项目，运行时报错如下：Error : java 不支持发行版本5 &nbsp; &nbsp; &nbsp; &nbsp;本地运行用的是JDK9，测试Java的Stream操作，报错应该是项目编译配置使用的Java版本不对，需要检查一下项目及环境使用的Java编译版本配置。 &nbsp; &nbsp; &nbsp; &nbsp;《1》在Intellij中点击“File” --&gt;“Project Structure”，看一下“Project”和“Module”栏目中Java版本是否与本地一致： &nbsp; 如果不一致，改成本地使用的Java版本。 &nbsp; &nbsp; &nbsp; 《2》点击“Settings”--&gt;“Bulid, Execution,Deployment”--&gt;“Java Compiler”，Target bytecode version设为本地Java版本。（可以在Default Settings中把Project bytecode version 一劳永逸地配置成本地Java版本） Default Settings： &nbsp; &nbsp; &nbsp; &nbsp;以上两步都配置好之后，重新运行应该就不会报上述错误了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/idea-bao-java-ban-ben-cuo-wu-jie-jue-fang-fa/"},{"title":"创建代码块模板","text":"创建代码块模板 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/chuang-jian-dai-ma-kuai-mo-ban/"},{"title":"利用IDEA学习编程语言","text":"安装学习插件EduTools 借助 EduTools 插件，您可以学习和教授编程语言，如 Kotlin、Java、Python、JavaScript、Rust、C/C++ 和 Scala，其形式是编码任务和自定义验证测试，直接位于基于 JetBrains IntelliJ 平台的 IDU 内部。 工作原理 安装 EduTools 插件：转到首选项 + 插件（或从欢迎屏幕配置 + 插件）并搜索 EduTools 插件。 作为一名教育家： 使用自定义任务、检查、测试、提示等创建您自己的交互式课程。 在Stepik、学习管理和 MOOC 平台上公开或私下与学生或同事分享您的课程。或者，您可以将课程保存为存档文件。 让学员在集成测试的协助下独立完成作业。 阅读本教程了解更多详情 作为学习者 ： 从列表中加入公共交互式编程课程，或从Stepik 选择课程，为 Java 开发人员解决 Kotlin的编程作业和算法工具箱课程，完成JetBrains 学院项目，解决CheckiO 的挑战。 根据任务描述在练习代码中填写占位符开始学习。 使用智能开发工具验证任务、获得即时反馈和快速结果。 阅读本教程了解更多详情 安装了这个插件相当于慕课网的网址编程作业一样，非常牛逼，可以自定义课程，我这里用来学习kotlin语言 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/li-yong-idea-xue-xi-bian-cheng-yu-yan/"},{"title":"快捷键","text":"格式化代码Ctrl+Alt+L 查看方法参数Ctrl+P 查看类、方法、属性注释Ctrl+Q document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/kuai-jie-jian/"},{"title":"插件使用","text":"codota(代码提示插件) 智能提示（ctrl + shift + o）和寻找案例（ctrl + shift + Y）： 代码完成当您编写代码时，Codota 会通过来自其 AI 的代码建议增强您的 IDE 自动完成。这些完成反映了从开放源代码中学到的常见编码模式，并省去主动搜索示例的需要。 触发代码完成Codota 添加的建议可以通过左侧的 codota 图标识别 （） Codota 建议以两种方式显示： 自动：当您编写代码时，它基于您键入的前缀显示。 按需：它使用键盘快捷方式（Cmd+空格/Ctrl+空格）显示 查看操作中的代码完成： 分配完成无论何时从特定类型分配变量，Codota 都会建议基于上下文和从开放源代码中学到的模型分配变量的方法。”等号 （”= “ ） 之后，您点击空格键后，Codota 建议将自动显示 建议可能包括正式参数类型和名称（文件、字符串文件名）： 如果选择了具有非基元参数的代码建议，这些参数将预加在上一行中（在选择”=新 FileReader（文件文件）”后添加文件）; 但是，如果 Codota 找到一个本地变量，该变量是一个很好的候选变量，它将将其绑定到建议（输入文件显示在建议中，并且未预报）： 在某些情况下，代码建议依赖于另一个对象。如果上下文中不存在此类对象，则建议以”…”开头，并在选择时预报此对象（注意：要创建需要连接的准备状态）。选择后，将在上一行中添加新的连接： 新线路完成新代码行通常以声明新的局部变量开头。在某些情况下，Codota 可以根据当前上下文预测要使用的下一个变量的类型。 在键入时，使用基本完成显示，按已键入的前缀进行筛选： 或者，按需使用 Ctrl+空间： 方法完成Codota 还可以帮助您预测给定对象中的下一个调用方法。最有可能的方法将由科多塔放在建议列表的顶部： 在某些情况下，Codota 预测在调用方法时将使用给定的局部变量。在这种情况下，将出现具有局部变量的方法建议，选择 Codota 的建议后，将用此方法粘贴参数。建议将突出显示一个黄色星形： 在 IDE Java 搜索中只需单击一下，您就会从 github 获得排名最高的代码段，这是堆栈流，并在编辑器旁边的 IDE 中查看它们。此过程使代码搜索更加方便。 编写良好的软件需要不断学习新的 API 或使用编程语言的不同元素。使用 Codota 在 IDE 中编写代码时搜索相关代码示例。只需单击一下，即可从 github 获得排名最高的代码段，该代码段是堆栈流，并在编辑器旁边的 IDE 中查看它们。此过程使代码搜索更加方便。 如何搜索对于给定的类或方法：要获取代码中使用的任何开源类或方法的相关示例，只需选择类或方法，然后右键单击**- 获取**相关示例或使用键快捷方式（默认值：Ctrl+Shift+O）） 代码片段将显示在 Codota 窗格中： 您还可以在使用键快捷方式 （Ctrl=Shift+O） 导航给定类的方法时触发搜索，并获取所选方法的最佳代码段： 使用 Codota 的自动完成从零开始搜索，您可以搜索任何开源类或方法的代码示例，即使它尚未在当前类中或当前类路径中不是事件。你可以去**”工具 + 科多塔搜索…”**或使用 Ctrl=Shift=Y 快捷方式： 将打开一个带搜索框的弹出窗口： 使用库多塔的自动完成机制键入搜索词： 选择术语时，相关示例将显示在侧面： 查看代码段相关的代码片段显示在 codota 窗格中的”代码段”选项卡中。对于每个代码段，您可以查看它来自堆栈流后、github 存储库还是 maven 项目。单击源标题，了解有关代码段源的信息： 或者查看帖子/源（如果您想要查看完整的源代码）。目前，每个搜索仅显示 20 个代码段，但在不久的将来，您将能够查看更多代码段或使用其他字词优化搜索。 下一个插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/idea/cha-jian-shi-yong/"},{"title":"Filter","text":"FilterFilter是什么？1. javaweb的一个重要组件，可以对发送到servlet的请求进行拦截，并对响应也进行拦截 2. Filter 是实现Filter 接口的java类 3. Filter 需要在web.xml中进行配置和映射 如何创建一个Filter，并把它跑起来`public class MyFilter implements Filter {` web.xml `&lt;filter&gt; &lt;filter-name&gt;别名&lt;/filter-name&gt; &lt;filter-class&gt;全类名&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;别名&lt;/filter-name&gt; &lt;url-pattern&gt;拦截url&lt;/url-pattern&gt; &lt;/filter-mapping&gt;` Filter 相关API1. init(FilterConfig filterConfig) 单例初始化 2. doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) 相关逻辑的处理 /放行，传给下一个filter 如果是最后一个Filter 则传给servler（jsp） filterChain.doFilter(servletRequest,servletResponse); 多个Filter 的拦截顺序与&lt;filter-mapping&gt;的配置顺序有关 靠前的先被调用 3. destroy()销毁 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/filter/"},{"title":"Linux","text":"Linuxlinux版本ubuntu:界面友好Red Hat：商业级-红帽认证工程师Centos：企业级-使用yum管理软件包linux组成部分内核 作用：运行程序管理硬件 进程管理，内存管理，硬件设备驱动，文件系统驱动 shell 作用：提供用户与内核进行交互操作接口（命令解释器） 文件结构 文件存放磁盘的组织方法 实用工具 编辑器：用于编辑文件 过滤器：用于接收并过滤数据 交互程序：容许用户发送信息或接收来自其他用户的信息 linux常用命令终端与工作区 alt+fx 用户和用户组管理 用户：user 切换用户：su 用户名 添加用户：useradd 选项 用户名 -c：描述 -d：目录 -g：用户组 -G：附加用户组 -s：用户登录shell -u：用户号 删除用户：userdel -r 用户名 修改账号：usermod 选项 用户名 设置密码：passwd 选项 用户名 强制设置简单密码：echo 123456 |passwd –stdin kujin -l 禁用账号 -u 解锁 -d 无口令 -f 下次登录修改口令 用户组：group groupadd 选项 用户组 -g：指定用户组标识GID -o：和-g差不多 groupdel 删除用户组 groupmod 选项 用户组 -g：GID -n：新用户组（新名字） 文件，目录操作命令 什么是路径？ 绝对路径 相对路径：cd ../ 处理目录的常用命令 ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 linux文件内容查看 cat 由第一行开始显示文件内容 tac 从最后一行开始显示 nl 显示行号 more 一页一页的显示 less 可以往前翻页 head 头部几行 tail 尾巴几行 文件信息显示XMind - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/linux/"},{"title":"1.学习网址","text":"[toc] 官方网址关键字查看 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/kotlin-xue-xi/1.xue-xi-wang-zhi/"},{"title":"数据类型","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/kotlin-xue-xi/shu-ju-lei-xing/"},{"title":"1-2 CentOS镜像使用帮助","text":"CentOS镜像使用帮助http://mirrors.163.com/.help/centos.html 1. 首先下载 wget yum install wget 2. 其次进行备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 3. 进入 /etc/yum.repos.d/ 目录，下载下载对应版本repo文件 cd /etc/yum.repos.d/ wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 4. 运行以下命令生成缓存 yum clean all yum makecache document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/1-2-centos-jing-xiang-shi-yong-bang-zhu/"},{"title":"2-1阿里云服务器远程登录密码","text":"远程登录密码 660593 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/2-1-a-li-yun-fu-wu-qi-yuan-cheng-deng-lu-mi-ma/"},{"title":"Centos虚拟机网络连接问题","text":"装好CentOS7后，我们一开始是上不了网的 这时候，可以输入命令dhclient，可以自动获取一个IP地址，再用命令ip addr查看IP 不过这时候获取的IP是动态的，下次重启系统后，IP地址也会变化，这时候我们可以把系统的IP设置为静态的，设置步骤如下： （1）点击VMware虚拟机左上角的“编辑”，选择“虚拟网络编译器”。 （2）选中VMnet8（NAT模式），再点击右侧的“NAT设置”此时会看到如下界面 （3）在命令行中输入：vim /etc/sysconfig/network-scripts/ifcfg-ens33 （4）此时会进入如下图所示界面 （5）将ONBOOT=no改为yes，将BOOTPROTO=dhcp改为BOOTPROTO=static,并在后面增加几行内容： IPADDR=192.168.127.128 NETMASK=255.255.255.0 GATEWAY=192.168.127.2 DNS1=119.29.29.29 （6）保存后退出，然后输入命令：systemctl restart network.service来重启网络服务。 （7）再用ip addr查看IP,并用命令ping测试网络的连通性。 至此，IP即设置完毕。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/centos-xu-ni-ji-wang-luo-lian-jie-wen-ti/"},{"title":"iptables的学习","text":"iptables什么是iptables常见与linux系统的应用层防火墙工具 什么是Netfilter?Netfilter是Linux操作系统核心层内部的一个数据包处理模块 什么是Hook point&gt; 数据包在Netfilter中的挂载点 （PRE_POUTING,INPUT,OUTPUT,FORWARD,POST_ROUTING） iptables规则组成组成部分：四张表+五条链（Hook point）+规则 四张表： filter表:访问控制，规则匹配 nat表：地址转发 mangle表， raw表 五条链：INPUT,OUTPUT,FORWARD,PREROUTING,POSTROUTING 数据包访问控制：ACCEPT,DROP,REJECT 数据包改写:SNAT,DNAT 信息记录：LOG iptables 配置 场景一》对所有的地址开放本机的tcp（80，22，10-21）端口的访问 》允许对所有的地址开放本机的基于ICMP协议的数据包访问 》其他未被允许的端口则禁止访问 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/iptables-de-xue-xi/"},{"title":"Linux准备工作","text":"CentOS虚拟机里的CentOS网络配置1.首先你要检查vm的网关ip是否和Centos 的IP一致 2. 前期准备工作 一.查看ip 1. ifconfig 2. ip addr 3. vi/ect/sysconfig/network-scripts/ifcfg-xx 4. yun install net-tool document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/linux-zhun-bei-gong-zuo/"},{"title":"LINUX设置防火墙","text":"Linux设置防火墙2019.02.25 11:01:08字数 42阅读 189Centos 7之前的防火墙基本都是修改iptables service iptables status 查看防火墙状态 service iptables start 开启防火墙 service iptables stop 关闭防火墙 service iptables restart 重启防火墙 Centos 7之后的防火墙升级为Firewall，取代了之前的iptables 其常用命令为： firewall-cmd --state ##查看防火墙运行状态，是否是running firewall-cmd –reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd –get-zones ##列出支持的zone firewall-cmd –get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd –list-ports ##列出开放的端口 firewall-cmd –query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd –add-service=ftp ##临时开放ftp服务 firewall-cmd –add-service=ftp –permanent ##永久开放ftp服务 firewall-cmd –remove-service=ftp –permanent ##永久移除ftp服务 firewall-cmd –add-port=80/tcp –permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 systemctl stop firewalld ##关闭防火墙 systemctl start firewalld ##开启防火墙 systemctl status firewalld ##查看防火墙状态 systemctl restart firewalld ##重启防火墙 systemctl disable firewalld ##开机关闭防火墙，即永久关闭 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/linux-she-zhi-fang-huo-qiang/"},{"title":"Nat连接网络","text":"虚拟机NAT模式连接SSH document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/nat-lian-jie-wang-luo/"},{"title":"Untitled","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/untitled/"},{"title":"文件命令操作md","text":"文件命令操作目录1、Linux命令的普遍语法格式2、目录处理命令 一、显示目录文件命令：ls 二、创建目录命令：mkdir 三、切换目录命令：cd 四、shell内置命令和外部命令的区别 五、显示当前目录命令：pwd 六、删除空目录命令：rmdir 七、复制文件或目录命令：cp 八、剪切文件或目录命令：mv 九、删除文件或目录命令：rm3、文件处理命令 一、创建空文件命令：touch 二、显示文件内容命令（适合内容较少的文件）：cat 三、反向显示文件内容命令（适合内容较少的文件）：tac 四、分页显示文件内容命令（不能向前翻页）：more 五、分页显示文件内容命令（可以前后翻页）：less 六、显示文件内容命令（指定行数）：head 七、反向文件内容命令（文件即时更新后也能动态显示，多用于日志文件显示）：tail4、总结 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/wen-jian-ming-ling-cao-zuo-md/"},{"title":"用户操作","text":"系统用户操作命令 useradd 选项 用户名 参数说明：选项: -c comment 指定一段注释性描述. -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/yong-hu-cao-zuo/"},{"title":"防火墙的设置","text":"防火墙的设置保护服务器的安全 设置防火墙规则 开放80 22端口 关闭防火墙 相关命令1. 安装 yum install firewalld 2. 启动 service firewalld start 3. 检查状态 service firewalld status 4. 关闭或禁用防火墙 service firewalld stop/disable document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/fang-huo-qiang-de-she-zhi/"},{"title":"index","text":"idea对项目创建创建的两种方式maven和gradle注意：idea对gradle的支持还不是很智能，对maven的依赖的好 mavengradle document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/maven-he-gradle/index/"},{"title":"错误问题","text":"Redis (error) NOAUTH Authentication required.解决方法认证错误，没有设置密码 auth \"密码\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/cuo-wu-wen-ti/"},{"title":"mysql数据库的安装与配置","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/qi-ye-ji-dian-shang-xiang-mu/mysql-shu-ju-ku-de-an-zhuang-yu-pei-zhi/"},{"title":"spring注解","text":"spring注解定义配置1. @Configuration 2. @ComoinentScan 定义组件1. @Component 2. @AutiWired 3. @Autowired(required=false) 自动装配歧义性1. @Primary 2. @Qualifier 3. @Resource 分层架构中定义组件1. @Controller 2. @Service 3. @Repository 4. @Repository Spring测试环境1. @RunWith 2. @ContextConfiguration 使用xml启用组件扫描&lt;comtext:component-scan base-package=\"com....\"/&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/spring/spring-zhu-jie/"},{"title":"iptables的学习","text":"iptables什么是iptables常见与linux系统的应用层防火墙工具 什么是Netfilter?Netfilter是Linux操作系统核心层内部的一个数据包处理模块 什么是Hook point&gt; 数据包在Netfilter中的挂载点 （PRE_POUTING,INPUT,OUTPUT,FORWARD,POST_ROUTING） iptables规则组成组成部分：四张表+五条链（Hook point）+规则 四张表： filter表:访问控制，规则匹配 nat表：地址转发 mangle表， raw表 五条链：INPUT,OUTPUT,FORWARD,PREROUTING,POSTROUTING 数据包访问控制：ACCEPT,DROP,REJECT 数据包改写:SNAT,DNAT 信息记录：LOG iptables 配置 场景一》对所有的地址开放本机的tcp（80，22，10-21）端口的访问 》允许对所有的地址开放本机的基于ICMP协议的数据包访问 》其他未被允许的端口则禁止访问 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/qi-ye-ji-dian-shang-xiang-mu/iptables-de-xue-xi/"},{"title":"LINUX设置防火墙","text":"Linux设置防火墙2019.02.25 11:01:08字数 42阅读 189Centos 7之前的防火墙基本都是修改iptables service iptables status 查看防火墙状态 service iptables start 开启防火墙 service iptables stop 关闭防火墙 service iptables restart 重启防火墙 Centos 7之后的防火墙升级为Firewall，取代了之前的iptables 其常用命令为： firewall-cmd --state ##查看防火墙运行状态，是否是running firewall-cmd –reload ##重新载入配置，比如添加规则之后，需要执行此命令 firewall-cmd –get-zones ##列出支持的zone firewall-cmd –get-services ##列出支持的服务，在列表中的服务是放行的 firewall-cmd –list-ports ##列出开放的端口 firewall-cmd –query-service ftp ##查看ftp服务是否支持，返回yes或者no firewall-cmd –add-service=ftp ##临时开放ftp服务 firewall-cmd –add-service=ftp –permanent ##永久开放ftp服务 firewall-cmd –remove-service=ftp –permanent ##永久移除ftp服务 firewall-cmd –add-port=80/tcp –permanent ##永久添加80端口 iptables -L -n ##查看规则，这个命令是和iptables的相同的 man firewall-cmd ##查看帮助 systemctl stop firewalld ##关闭防火墙 systemctl start firewalld ##开启防火墙 systemctl status firewalld ##查看防火墙状态 systemctl restart firewalld ##重启防火墙 systemctl disable firewalld ##开机关闭防火墙，即永久关闭 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/qi-ye-ji-dian-shang-xiang-mu/linux-she-zhi-fang-huo-qiang/"},{"title":"vsftpd","text":"简介vsftpd是“very secure FTP daemon”的缩写是一个完全免费，开放源代码的ftp服务器软件 特点vsftpd是一款Linux发行版中最受推崇的ftp服务器程序，小巧轻快，安全易用，支持带宽限制等功能 安装1. 执行 yum -y install vsftpd 1. 默认配置文件在/etc/vsftpd/vsftpd.conf 2. 创建虚拟用户 1. 选择根或者用户目录下创建ftp文件夹：mkdir ftpfile,如：/ftpfile 2. 添加匿名用户：useradd ftpuser -d /ftpfile -s /sbin/nologin 3. 修改ftpfile权限：chown -R ftpuser.ftpuser /ftpfie 4. 重设ftpuser密码：password ftpuser(12346) 3. 配置 1. cd /etc/vsftpd 2. sudo vim chroot_list 3. 把刚才新增的虚拟用户添加到此配置文件中，后续要引用 4. :wq 保存退出 5. sudo vim /etc/selinux/config,修改SELINUX=disabled 6. :wq 保存退出 如果遇到550拒绝访问执行sudo setsebool -P ftp_home_dir 1 然后重启linux服务区，执行reboot命令 7. sudo vim /etc/vsftpd/vsftpd.conf 8. 添加配置或更新配置 4. 防火墙配置 1. sudo vim /etc/sysconfig/iptables 2.1. -A INPUT -p TCP --dport 61001:62000 -j ACCEPT 2.2. -A OUTPUT -p TCP --sport 61001:62000 -j ACCEPT 2.1. -A INPUT -p TCP --dport 20 -j ACCEPT 2.2. -A OUTPUT -p TCP --sport 20 -j ACCEPT 2.1. -A INPUT -p TCP --dport 21 -j ACCEPT 2.2. -A OUTPUT -p TCP --sport 21 -j ACCEPT 3. :wq 保存退出 4. sudo service iptables restart 执行命令重启防火墙 vsftpd验证1. 执行 sodo service vsftpd restart 2. 执行ifconfig 查看运行vsftpd服务器的ip地址 3. 打开浏览器访问：ftp://10.211.55.6 4. 输入之前创建的ftp匿名用户账号和密码 5. 通过ftp客户端软件 常用命令启动 sudo service vsftpd start 关闭 sudo service vsftpd stop 重启 sudo service vsftpd restart document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/qi-ye-ji-dian-shang-xiang-mu/vsftpd/"},{"title":"框架搭建","text":"Spring Boot +Spring Security 快速搭建spring项目官方网址 通过idea快速创建springboot file-&gt;new Project-&gt;Spring Intializr常见注解@SpringBootApplication：@RestController:相当于@ResponseBody document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/qi-ye-ji-quan-xian-guan-li/kuang-jia-da-jian/"},{"title":"Spring Framework简介","text":"[TOC] 官方网址：https://spring.io/projects 参考网址：https://spring.io/projects/spring-framework clone 地址：https://github.com/kujin521/spring Spring Framework The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform. Spring 框架为现代基于 java 的企业应用程序提供了一个全面的编程和配置模型，适用于任何类型的部署平台。 A key element of Spring is infrastructural support at the application level: Spring focuses on the “plumbing” of enterprise applications so that teams can focus on application-level business logic, without unnecessary ties to specific deployment environments. Spring 的一个关键元素是应用程序级别的基础设施支持: Spring 关注企业应用程序的”管道”，这样团队就可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。 功能 核心技术: 依赖注入、事件、资源、 i18n、验证、数据绑定、类型转换、 SpEL、 AOP。 测试: 模拟对象，TestContext 框架，Spring MVC Test，WebTestClient。 数据访问: 事务，DAO 支持，JDBC，ORM，封送 XML。 集成: 远程处理、 JMS、 JCA、 JMX、电子邮件、任务、调度、缓存。 语言: Kotlin，Groovy，动态语言。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/spring/spring-yuan-ma-xue-xi/spring-framework-jian-jie/"},{"title":"问题总结","text":"[TOC] idea下载spring源码编译不通过找不到xx.xx.jar 解决方式：查看连接，发现确实没有这个jar，由于sping使用的是最新版本的依赖，尝试使用旧版本，发现旧版本有相应的jar，但版本不一致，缺少很多包。 怀疑是网络问题，分别加上阿里云maven和使用源代码，分别编译，科学上网，结论：不行！ 怀疑是第三方还没有公开最新jar，果断放弃，果然第二天，再次编译，成功下载jar，查看昨天的网址发现有了jar，编译通过！！ http://nexus.bsdn.org/content/groups/public/io/projectreactor/reactor-core/3.4.0-M1/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/spring/spring-yuan-ma-xue-xi/wen-ti-zong-jie/"},{"title":"1-1 入门学习","text":"配置Mybatis-Spring项目官方文档 官方实例代码：https://github.com/mybatis/jpetstore-6.git 1.配置数据源（简单版）&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\"> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"123456\"/> &lt;property name=\"driverClass\" value=\"com.mysql.cj.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/chapter12\"/> &lt;/bean> 2.配置SqlSessionFactory document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/spring/spring-mybatis-xiang-mu/1-1-ru-men-xue-xi/"},{"title":"学习记录（一）","text":"[Toc] 简介测试是企业软件开发不可或缺的一部分。本章重点介绍IoC原则对单元测试的价值，以及春框架支持集成测试的好处。（对企业中的测试进行彻底处理超出了本参考手册的范围。 1.单元测试 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/spring/springtest/xue-xi-ji-lu-yi/"},{"title":"01 Spring Boot入门","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/wei-ren-shi-xiang-mu-guan-li/01-spring-boot-ru-men/"},{"title":"需求文档","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/wei-ren-shi-xiang-mu-guan-li/xu-qiu-wen-dang/"},{"title":"PermissionX权限管理库","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/bian-xie-kai-yuan-ku/permissionx-quan-xian-guan-li-ku/"},{"title":"前期准备","text":"天气数据API 接口获取彩云天气 https://dashboard.caiyunapp.com/ api文档阅读 https://open.caiyunapp.com/%E5%BD%A9%E4%BA%91%E5%A4%A9%E6%B0%94_API_%E4%B8%80%E8%A7%88%E8%A1%A8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/tian-qi-yu-bao-app/qian-qi-zhun-bei/"},{"title":"功能需求与技术可行性分析","text":"功能分析 可以搜索各个国家的城市数据 可以查看全球大多数城市的天气信息 可以自由的切换城市，查看其他城市的天气信息 可以手动刷新实时的天气 技术分析 UI 网络 数据存储 异步处理 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/tian-qi-yu-bao-app/gong-neng-xu-qiu-yu-ji-zhu-ke-xing-xing-fen-xi/"},{"title":"2-1android moudle与libery切换","text":"Application与Library切换 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/kotlin-kai-fa-dian-shang-app/2-1android-moudle-yu-libery-qie-huan/"},{"title":"项目知识点","text":"后端技术 Spring boot (SSM) spring Secunity Redis POI/邮件发送/消息中间件 Mysql 前端技术 Vue axios ElemnetUI Vuex document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/wei-ren-shi-xiang-mu-guan-li/xiang-mu-zhi-shi-dian/"},{"title":"1-1-安装环境","text":"开发工具和环境 工具 版本 idea（ide） 2020.1 git（版本控制）github 2.26 maven（项目构建） 3.6 tomcat（web容器） 9 Java jdk 1.8 mysql 8 本地系统 win10 服务器 Centos7 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/tao-tao-shang-cheng-xiang-mu-shi-zhan/1-1-an-zhuang-huan-jing/"},{"title":"项目前期构建","text":"人员配置产品经理：3人，确定需求及给出产品原型 项目经理：1人，项目管理 前端团队：5人，根据产品经理给出原型制作静态页面 后端团队：20人，实现产品功能 测试团队：5人，测试所有功能 运维团队：3人，项目的发布和维护 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/xiang-mu-shi-zhan/tao-tao-shang-cheng-xiang-mu-shi-zhan/xiang-mu-qian-qi-gou-jian/"},{"title":"3-1网络访问","text":"[toc] 1.WebView的用法 WevView是andorid控件,可以显示简单的网页 编写main.xml界面 关键代码 添加AndroidMainifest.xml权限 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" > &lt;WebView android:id=\"@+id/webView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /> &lt;/LinearLayout> //设置一些浏览器属性,支持JavaScript脚本 webView.settings.setJavaScriptEnabled(true) //获取实例,设置url webView.webViewClient = WebViewClient() webView.loadUrl(\"https://www.baidu.com\") &lt;uses-permission android:name=\"android.permission.INTERNET\" /> 2.使用HttpURLConnectionprivate fun sendRequestWithHttpURLConnection() &amp;#123; // 开启线程来发起网络请求 thread &amp;#123; var connection: HttpURLConnection? = null try &amp;#123; val response = StringBuilder() //1. 创建url,获取HttpURLConnection实例 val url = URL(\"https://www.baidu.com\") connection = url.openConnection() as HttpURLConnection //2. 设置请求方式,连接超时,读取时间 connection.requestMethod=\"GET\" connection.connectTimeout = 8000 connection.readTimeout = 8000 //3. 获取服务器返回的输入流 val input = connection.inputStream // 下面对获取到的输入流进行读取 val reader = BufferedReader(InputStreamReader(input)) reader.use &amp;#123; reader.forEachLine &amp;#123; response.append(it) &amp;#125; &amp;#125; showResponse(response.toString()) &amp;#125; catch (e: Exception) &amp;#123; e.printStackTrace() &amp;#125; finally &amp;#123; connection?.disconnect() &amp;#125; &amp;#125; &amp;#125; private fun showResponse(response: String) &amp;#123; runOnUiThread &amp;#123; // 在这里进行UI操作，将结果显示到界面上 responseText.text = response &amp;#125; &amp;#125; post请求设置connection.requestMethod=\"POST\" val output=DataOutputStream(connection.outputStream) output.writeUTF(\"UTF-8\") output.writeBytes(\"username=admin&amp;password=123456\") 3.使用OkHttp(推荐)首选的android开源网络通信库 github:https://square.github.io/okhttp/ 添加依赖 关键代码 添加权限 implementation(\"com.squareup.okhttp3:okhttp:4.8.0\") private fun sendRequestWithOkHttp() &amp;#123; thread &amp;#123; try &amp;#123; //1. 获取okhttp实例 val client = OkHttpClient() //2. 设置请求参数 //post请求(可选) val requestBody=FormBody.Builder() .add(\"username\",\"admin\") .add(\"password\",\"123456\") .build() val request = Request.Builder() .url(\"https://www.baidu.com\") //.post(requestBody) .build() //3. 获取服务器返回的数据 val response = client.newCall(request).execute() val responseData = response.body?.string() if (responseData != null) &amp;#123; showResponse(responseData) &amp;#125; &amp;#125; catch (e: Exception) &amp;#123; e.printStackTrace() &amp;#125; &amp;#125; &amp;#125; private fun showResponse(response: String) &amp;#123; runOnUiThread &amp;#123; // 在这里进行UI操作，将结果显示到界面上 responseText.text = response &amp;#125; &amp;#125; &lt;uses-permission android:name=\"android.permission.INTERNET\" /> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/3-1-wang-luo-fang-wen/"},{"title":"3-2-1安装Apache服务器","text":"打开Apache文件夹： 打开conf文件夹下的：httpd.conf文件，将Apache的目录位置修改为当前你Apache安装存放的位置： 在cmd命令下输入：netstat -a，查看80端口是否被占用，如果被占用，将：httpd.conf文件中的80端口改为其他端口后保存 配置安装Apache的主服务，在cmd中输入：”E:\\Apache-2.4.37\\Apache\\bin\\httpd.exe” -k install -n apache，注意一定要加引号，然后回车，如果出现如下信息，说明配置成功了，如果出现：“os 5拒绝访问”的错误，说明是你的管理权限限制，这个时候关闭cmd，然后重新以管理员身份运行cmd，再进行上一步操作，问题就能解决了： 启动Apache服务：双击bin目录下的：ApacheMonitor.exe，然后会在电脑右下角出现它的显示符号，双击这个符号，在弹出的窗口中点击start就行了。 注意：关闭Apache服务点击stop来关闭，当然也可以Windows系统来关闭 打开浏览器，在网址栏输入：127.0.0.1(或者：http://localhost)，出现如下界面就表示配置成功了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/3-2-1-an-zhuang-apache-fu-wu-qi/"},{"title":"3-2网络访问-数据格式","text":"[toc] 1.创建一个本地简单的服务器apache服务器: https://www.apachehaus.com/cgi-bin/download.plx#APACHELEVC14 2.解析XML格式数据 在桌面编写一个get_data.xml文件 请求网络代码 解析xml 由于android9开始不支持http请求,默认是https,需要配置,创建res/xml/network_config.xml 声明权限 &lt;apps> &lt;app> &lt;id>1&lt;/id> &lt;name>Google Maps&lt;/name> &lt;version>1.0&lt;/version> &lt;/app> &lt;app> &lt;id>2&lt;/id> &lt;name>Chrom&lt;/name> &lt;version>2.1&lt;/version> &lt;/app> &lt;app> &lt;id>3&lt;/id> &lt;name>Google Play&lt;/name> &lt;version>2.3&lt;/version> &lt;/app> &lt;/apps> private fun sendRequestWithOkHttp() &amp;#123; thread &amp;#123; try &amp;#123; //1. 获取okhttp实例 val client = OkHttpClient() //2. 设置请求参数 //post请求(可选) val requestBody=FormBody.Builder() .add(\"username\",\"admin\") .add(\"password\",\"123456\") .build() val request = Request.Builder() //.url(\"https://www.baidu.com\") //读取本地服务器文件 .url(\"http://192.168.2.228/get_data.xml\") //.post(requestBody) .build() //3. 获取服务器返回的数据 val response = client.newCall(request).execute() val responseData = response.body?.string() if (responseData != null) &amp;#123; //showResponse(responseData) //解析xml数据 parseXMLWithPull(responseData) &amp;#125; &amp;#125; catch (e: Exception) &amp;#123; e.printStackTrace() &amp;#125; &amp;#125; &amp;#125; /** * 解析xml数据格式 * Pull方式 */ private fun parseXMLWithPull(xmlData: String) &amp;#123; try &amp;#123; //1. 创建XmlPullParserFactory实例,获取XmlPullParser对象 val factory = XmlPullParserFactory.newInstance() val xmlPullParser = factory.newPullParser() //2. 将服务器返回的XML设置进去,开始解析 xmlPullParser.setInput(StringReader(xmlData)) //3. 得到当前解析事件 var eventType = xmlPullParser.eventType var id = \"\" var name = \"\" var version = \"\" //4. 遍历解析事件 while (eventType != XmlPullParser.END_DOCUMENT) &amp;#123; val nodeName = xmlPullParser.name when (eventType) &amp;#123; //4.1 开始解析某个节点 XmlPullParser.START_TAG -> &amp;#123; when (nodeName) &amp;#123; //如果节点名等于id name version 就调用nextText()获取节点内容 \"id\" -> id = xmlPullParser.nextText() \"name\" -> name = xmlPullParser.nextText() \"version\" -> version = xmlPullParser.nextText() &amp;#125; &amp;#125; //4.2 完成解析某个节点,打印节点内容 XmlPullParser.END_TAG -> &amp;#123; if (\"app\" == nodeName) &amp;#123; Log.d(\"MainActivity\", \"id is $id\") Log.d(\"MainActivity\", \"name is $name\") Log.d(\"MainActivity\", \"version is $version\") &amp;#125; &amp;#125; &amp;#125; eventType = xmlPullParser.next() &amp;#125; &amp;#125; catch (e: Exception) &amp;#123; e.printStackTrace() &amp;#125; &amp;#125; &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;network-security-config> &lt;base-config cleartextTrafficPermitted=\"true\"> &lt;trust-anchors> &lt;certificates src=\"system\" /> &lt;/trust-anchors> &lt;/base-config> &lt;/network-security-config> &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.networktest\"> &lt;!-- 声明网络权限--> &lt;uses-permission android:name=\"android.permission.INTERNET\" /> &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\" android:networkSecurityConfig=\"@xml/network_config\"> &lt;!-- 设置http请求--> &lt;activity android:name=\".MainActivity\"> &lt;intent-filter> &lt;action android:name=\"android.intent.action.MAIN\" /> &lt;category android:name=\"android.intent.category.LAUNCHER\" /> &lt;/intent-filter> &lt;/activity> &lt;/application> &lt;/manifest> 3.解析JSON格式数据 在htdocs目录下创建一个get_data.json文件 编写解析代码 [ &amp;#123;\"id\":\"5\",\"version\":\"5.5\",\"name\":\"Clash of Clans\"&amp;#125;, &amp;#123;\"id\":\"6\",\"version\":\"7.0\",\"name\":\"Boom Beach\"&amp;#125;, &amp;#123;\"id\":\"7\",\"version\":\"3.5\",\"name\":\"Clash Royale\"&amp;#125; ] /** * 使用官方提供的JsonObject */ private fun parseJSONWithJSONObject(jsonData: String) &amp;#123; try &amp;#123; //1. 获取jsonarray,进行循环解析 val jsonArray = JSONArray(jsonData) //2. 如果循环中不要最后一个范围区间的值可以使用 until 函数: for (i in 0 until jsonArray.length()) &amp;#123; val jsonObject = jsonArray.getJSONObject(i) val id = jsonObject.getString(\"id\") val name = jsonObject.getString(\"name\") val version = jsonObject.getString(\"version\") Log.d(\"MainActivity\", \"id is $id\") Log.d(\"MainActivity\", \"name is $name\") Log.d(\"MainActivity\", \"version is $version\") &amp;#125; &amp;#125; catch (e: Exception) &amp;#123; e.printStackTrace() &amp;#125; &amp;#125; 4.优化解析,使用GSON开源库1.导入gson依赖implementation 'com.google.code.gson:gson:2.8.5' 一段json数据 &amp;#123;\"name\":\"Tom\",\"age\":20&amp;#125; val gson=Gson() val person=gson.fromJson(jsonData,Person::class.java) 解析json数组 [ &amp;#123;\"id\":\"5\",\"version\":\"5.5\",\"name\":\"Clash of Clans\"&amp;#125;, &amp;#123;\"id\":\"6\",\"version\":\"7.0\",\"name\":\"Boom Beach\"&amp;#125;, &amp;#123;\"id\":\"7\",\"version\":\"3.5\",\"name\":\"Clash Royale\"&amp;#125; ] val typeOf = object : TypeToken&lt;List&lt;App>>() &amp;#123;&amp;#125;.type val appList = gson.fromJson&lt;List&lt;App>>(jsonData, typeOf) 2.根据gson格式,编写实体类,class App(val id: String, val name: String, val version: String) /** * 利用Gson解析json数据 */ private fun parseJSONWithGSON(jsonData: String) &amp;#123; //1. 获取gson实例 val gson = Gson() //2. 设置gson数据格式 val typeOf = object : TypeToken&lt;List&lt;App>>() &amp;#123;&amp;#125;.type val appList = gson.fromJson&lt;List&lt;App>>(jsonData, typeOf) //3. 循环遍历jsonarray数据 for (app in appList) &amp;#123; Log.d(\"MainActivity\", \"id is $&amp;#123;app.id&amp;#125;\") Log.d(\"MainActivity\", \"name is $&amp;#123;app.name&amp;#125;\") Log.d(\"MainActivity\", \"version is $&amp;#123;app.version&amp;#125;\") &amp;#125; &amp;#125; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/3-2-wang-luo-fang-wen-shu-ju-ge-shi/"},{"title":"3-3 封装网络请求","text":"1.HttpURLConnection网络封装 定义接口 编写工具类 测试应用 /** * 创建http回调接口 */ interface HttpCallbackListener &amp;#123; //服务器成功响应 fun onFinish(response: String) //服务器响应失败 fun onError(e: Exception) &amp;#125; object HttpUtil &amp;#123; fun sendHttpRequest(address: String, listener: HttpCallbackListener) &amp;#123; thread &amp;#123; var connection: HttpURLConnection? = null try &amp;#123; val response = StringBuilder() val url = URL(address) connection = url.openConnection() as HttpURLConnection connection.connectTimeout = 8000 connection.readTimeout = 8000 val input = connection.inputStream val reader = BufferedReader(InputStreamReader(input)) reader.use &amp;#123; reader.forEachLine &amp;#123; response.append(it) &amp;#125; &amp;#125; // 回调onFinish()方法 listener.onFinish(response.toString()) &amp;#125; catch (e: Exception) &amp;#123; e.printStackTrace() // 回调onError()方法 listener.onError(e) &amp;#125; finally &amp;#123; connection?.disconnect() &amp;#125; &amp;#125; &amp;#125; &amp;#125; fun main() &amp;#123; //创建一个新的协程运行 runBlocking &amp;#123; getBaiduResponse() &amp;#125; &amp;#125; suspend fun getBaiduResponse() &amp;#123; try &amp;#123; val response = request(\"https://www.baidu.com/\") // 得到服务器返回的具体内容 println(response) &amp;#125; catch (e: Exception) &amp;#123; // 在这里对异常情况进行处理 &amp;#125; &amp;#125; suspend fun request(address: String): String &amp;#123; return suspendCoroutine &amp;#123; continuation -> HttpUtil.sendHttpRequest(address, object : HttpCallbackListener &amp;#123; override fun onFinish(response: String) &amp;#123; continuation.resume(response) &amp;#125; override fun onError(e: Exception) &amp;#123; continuation.resumeWithException(e) &amp;#125; &amp;#125;) &amp;#125; &amp;#125; 2.Okhttp网络封装/** * callback: okhttp3.Callback: okhttp自带的回调接口 */ fun sendOkHttpRequest(address: String, callback: okhttp3.Callback) &amp;#123; val client = OkHttpClient() val request = Request.Builder() .url(address) .build() client.newCall(request).enqueue(callback) &amp;#125; HttpUtil.sendOkHttpRequest(address,object :Callback&amp;#123; override fun onFailure(call: Call, e: IOException) &amp;#123; //处理异常数据 &amp;#125; override fun onResponse(call: Call, response: Response) &amp;#123; //得到服务器返回的具体内容 val reponseData=response.body?.string() &amp;#125; &amp;#125;) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/3-3-feng-zhuang-wang-luo-qing-qiu/"},{"title":"3-4 开源网络封装库Retofit","text":"1.简介2.Retrofit基本用法2.1添加依赖 implementation 'com.squareup.retrofit2:retrofit:2.6.1' implementation 'com.squareup.retrofit2:converter-gson:2.6.1' 2.2.编写gson实体类class App(val id: String, val name: String, val version: String) 2.3创建接口interface AppService &amp;#123; /** * 使用get请求,参数是请求相对地址 * 返回类型是 对应的实体类 */ @GET(\"get_data.json\") fun getAppData(): Call&lt;List&lt;App>> &amp;#125; 2.4Activity界面编辑&lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" > &lt;Button android:id=\"@+id/getAppDataBtn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Get App Data\" /> &lt;/LinearLayout> document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/3-4-kai-yuan-wang-luo-feng-zhuang-ku-retofit/"},{"title":"Android Studio使用技巧","text":"[toc] IDE技巧1. 提取样式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/android-studio-shi-yong-ji-qiao/"},{"title":"BottomNavigationView控件学习md","text":"as可直接生成底部导航 相关文件 注意menu-&gt;item-&gt;id 要和 navigation-&gt;fragment-&gt;id 保持一致&lt;br&gt; startDestination:启动页面 核心代码 private void setNav() { states = new int[][] { new int[] { android.R.attr.state_selected}, // 选中状态 new int[] { android.R.attr.state_enabled} // 未选中状态 }; colors = new int[] { Color.BLUE, Color.GRAY }; ColorStateList myList = new ColorStateList(states, colors); BottomNavigationView navView = findViewById(R.id.nav_view); navView.setItemTextColor(myList);//设置item文字颜色 navView.setItemIconTintList(myList);//设置item图片颜色 NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment); NavigationUI.setupWithNavController(navView, navController); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/bottomnavigationview-kong-jian-xue-xi-md/"},{"title":"Jetpack","text":"[toc] Jetpack简介Jetpack是一个开发组件工具集，官网：https://developer.android.google.cn/jetpack Jetpack 是一套库，可帮助开发人员遵循最佳实践，减少样板代码，并编写跨 Android 版本和设备一致工作的代码，以便开发人员可以专注于他们关心的代码。 Jetpack 库可以单独使用，也可以组合使用，以满足应用的不同需求。 WorkManager - 满足您的后台调度需求。 Room - 实现数据存储持久性。 Navigation - 管理应用导航流程。 CameraX - 满足相机应用需求。 请参阅所有 Jetpack 库的概览。 ViewModel简介ViewModel是Jetpack组件之一，在传统Activity中需要负责逻辑处理，又要控制UI展示，甚至还得处理网络回调，现在ViewModel将负责Activity的数据部分 当手机旋转时Activity会被重新创建，但ViewModel生命周期是Activtity创建到销毁全过程，所以旋转不会导致数据丢失 简单的计时器 导入依赖def lifecycle_version = \"2.2.0\" implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\" ​ 创建ViewModelimport androidx.lifecycle.ViewModel class MainModel:ViewModel() &amp;#123; var counter=0 &amp;#125; 编写Activity&lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"> &lt;TextView android:id=\"@+id/infoText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:text=\"@string/jishi\" /&gt; &lt;Button android:id=\"@+id/plusOnBtn\" android:layout_gravity=\"center_vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/pulus_one\" /&gt; ``` package com.kj.scoreviewmodel import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import androidx.lifecycle.ViewModelProviders import kotlinx.android.synthetic.main.activity_main.* class MainActivity : AppCompatActivity() &amp;#123; //定义viewmodel lateinit var viewModel: MainModel override fun onCreate(savedInstanceState: Bundle?) &amp;#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //初始化viewmodel viewModel= ViewModelProviders.of(this).get(MainModel::class.java) //button点击事件 plusOnBtn.setOnClickListener &amp;#123; viewModel.counter++ refreshCounter() &amp;#125; refreshCounter() &amp;#125; //更新视图 private fun refreshCounter() &amp;#123; infoText.text=viewModel.counter.toString() &amp;#125; &amp;#125; 向ViewModel传递参数import androidx.lifecycle.ViewModel //添加构造参数 class MainModel2(counter:Int): ViewModel() &amp;#123; var counter=counter &amp;#125; import androidx.lifecycle.ViewModel import androidx.lifecycle.ViewModelProvider //利用ViewModelProvider.Factory 接口 实现构造函数 class MainViewModelFactory(private val counter: Int) : ViewModelProvider.Factory &amp;#123; override fun &lt;T : ViewModel?> create(modelClass: Class&lt;T>): T &amp;#123; return MainModel2(counter) as T &amp;#125; &amp;#125; import android.content.Context import android.content.SharedPreferences import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import androidx.lifecycle.ViewModelProviders import kotlinx.android.synthetic.main.activity_main.* class MainActivity2 : AppCompatActivity() &amp;#123; lateinit var viewModel:MainModel2 lateinit var sp: SharedPreferences override fun onCreate(savedInstanceState: Bundle?) &amp;#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) sp=getPreferences(Context.MODE_PRIVATE) val countReserved=sp.getInt(\"count_reserved\",0) //初始化viewmodel（修改点） viewModel= ViewModelProviders.of(this,MainViewModelFactory(countReserved)).get(MainModel2::class.java) //button点击事件 plusOnBtn.setOnClickListener &amp;#123; viewModel.counter++ refreshCounter() &amp;#125; refreshCounter() &amp;#125; override fun onPause() &amp;#123; super.onPause() sp.edit().putInt(\"count_reserved\",viewModel.counter).apply() &amp;#125; //更新视图 private fun refreshCounter() &amp;#123; infoText.text=viewModel.counter.toString() &amp;#125; &amp;#125; 更正由于ViewModel 设计理念是不依赖与Activity使用google推荐的写法class UserProfileViewModel : ViewModel() &amp;#123; val userId : String = TODO() val user : User = TODO() &amp;#125; private val viewModel: UserProfileViewModel by viewModels() 遇到的错误Cannot inline bytecode built with JVM target 1.8 into bytecode that is being built with JVM target //解决 android &amp;#123; ... compileOptions &amp;#123; sourceCompatibility = 1.8 targetCompatibility = 1.8 &amp;#125; kotlinOptions &amp;#123; jvmTarget = \"1.8\" &amp;#125; &amp;#125; Lifecycles简介在网络请求中，由于网络响应延迟，页面关闭情况，我们要对activity生命周期进行逻辑处理 监听器import android.util.Log import androidx.lifecycle.Lifecycle import androidx.lifecycle.LifecycleObserver import androidx.lifecycle.OnLifecycleEvent class MyObserver(val lifecycle: Lifecycle) : LifecycleObserver &amp;#123; @OnLifecycleEvent(Lifecycle.Event.ON_START) fun activityStart()&amp;#123; Log.d(\"MyObserver\", \"activityStart: \") &amp;#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun activityStop()&amp;#123; Log.d(\"MyObserver\", \"activityStop: \") &amp;#125; &amp;#125; //activity监听生命周期 MyObserver(lifecycle) val currentState = lifecycle.currentState Toast.makeText(this, \"\"+currentState, Toast.LENGTH_SHORT).show() LiveDataLiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。 您可以注册与实现 LifecycleOwner 接口的对象配对的观察者。有了这种关系，当相应的 Lifecycle 对象的状态变为 DESTROYED 时，便可移除此观察者。 这对于 Activity 和 Fragment 特别有用，因为它们可以放心地观察 LiveData 对象而不必担心泄露（当 Activity 和 Fragment 的生命周期被销毁时，系统会立即退订它们）。 确保界面符合数据状态 不会发生内存泄漏 不会因Activity停止导致崩溃 不需要手动处理生命周期 数据保持最新状态 适当的配置更改 共享资源 1.使用LiveData对象 创建 LiveData 实例以存储某种类型的数据。这通常在 ViewModel 类中完成。 创建可定义 onChanged() 方法的 Observer 对象，该方法可以控制当 LiveData 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中创建 Observer 对象。 使用 [observe()](https://developer.android.google.cn/reference/androidx/lifecycle/LiveData#observe(android.arch.lifecycle.LifecycleOwner, android.arch.lifecycle.Observer)) 方法将 Observer 对象附加到 LiveData 对象。observe() 方法会采用 LifecycleOwner 对象。这样会使 Observer 对象订阅 LiveData 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 Observer 对象。 import androidx.lifecycle.MutableLiveData import androidx.lifecycle.ViewModel class NameViewModel : ViewModel() &amp;#123; // 用字符串创建一个LiveData val currentName: MutableLiveData&lt;String> by lazy &amp;#123; MutableLiveData&lt;String>() &amp;#125; // ViewModel的其余部分… &amp;#125; class NameActivity : AppCompatActivity() &amp;#123; // 使用'by viewModels()' Kotlin属性委托 // 来自activity-ktx工件 private val model: NameViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) &amp;#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_name) // 创建用于更新UI的观察者。 val nameObserver = Observer&lt;String> &amp;#123; newName -> // 更新UI，这里是TextView。 nameTextView.text = newName &amp;#125; // 观察LiveData，将此活动作为LifecycleOwner和observer传递进来。 model.currentName.observe(this, nameObserver) // 修改参数 button.setOnClickListener &amp;#123; model.currentName.setValue(edText.text.toString()) //model.currentName.postValue(edText.text.toString()) &amp;#125; &amp;#125; &amp;#125; 2.map和switchMap的使用 定义一个User类 data class User(var fistName:String,var lastName:String,var age:Int) 编写ViewModel class MainViewModel(countReserved:Int):ViewModel()&amp;#123; private val userLiveData=MytableLiveData&lt;User>() val userName:LiveData&lt;String>=Transformations.map(userLiveData)&amp;#123;user-> \"$&amp;#123;user.firstName&amp;#125; $&amp;#123;user.lastName&amp;#125;\" &amp;#125; &amp;#125; Room Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。 Room 包含 3 个主要组件： 数据库：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。 使用 @Database 注释的类应满足以下条件： 是扩展 RoomDatabase 的抽象类。 在注释中添加与数据库关联的实体列表。 包含具有 0 个参数且返回使用 @Dao 注释的类的抽象方法。 在运行时，您可以通过调用 [Room.databaseBuilder()](https://developer.android.google.cn/reference/androidx/room/Room#databaseBuilder(android.content.Context, java.lang.Class, java.lang.String)) 或 [Room.inMemoryDatabaseBuilder()](https://developer.android.google.cn/reference/androidx/room/Room#inMemoryDatabaseBuilder(android.content.Context, java.lang.Class)) 获取 Database 的实例。 Entity：表示数据库中的表。 DAO：包含用于访问数据库的方法。 应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。 简单使用导入依赖 def room_version = \"2.2.5\" implementation \"androidx.room:room-runtime:$room_version\" //annotationProcessor \"androidx.room:room-compiler:$room_version\" // 对于Kotlin来说，使用kapt而不是annotationProcessor kapt \"androidx.room:room-compiler:$room_version\" // 对于Kotlin来说，使用kapt而不是annotationProcessor // 可选- Kotlin扩展和协同程序支持空间 implementation \"androidx.room:room-ktx:$room_version\" // 可选- RxJava支持房间 implementation \"androidx.room:room-rxjava2:$room_version\" // 可选-番石榴支持房间，包括可选和ListenableFuture implementation \"androidx.room:room-guava:$room_version\" // 测试助手 testImplementation \"androidx.room:room-testing:$room_version\" User //数据库的表 @Entity data class User( @ColumnInfo(name = \"first_name\") val firstName: String?, @ColumnInfo(name = \"last_name\") val lastName: String? )&amp;#123; @PrimaryKey(autoGenerate = true) var uid: Long=0 &amp;#125; UserDao //数据访问对象 @Dao interface UserDao &amp;#123; @Query(\"SELECT * FROM user\") fun getAll(): List&lt;User> @Query(\"SELECT * FROM user WHERE uid IN (:userIds)\") fun loadAllByIds(userIds: IntArray): List&lt;User> @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" + \"last_name LIKE :last LIMIT 1\") fun findByName(first: String, last: String): User @Insert fun insertUser(user: User):Long @Delete fun delete(user: User) &amp;#125; AppDatabase @Database(entities = arrayOf(User::class), version = 1) abstract class AppDatabase : RoomDatabase() &amp;#123; abstract fun userDao(): UserDao &amp;#125; 创建上述文件后，您可以使用以下代码获取已创建的数据库的实例： //定义数据库对象，数据库版本，包含的实体类 @Database(entities = [User::class], version = 1) abstract class AppDatabase : RoomDatabase() &amp;#123; abstract fun userDao(): UserDao companion object&amp;#123; private var instance: AppDatabase?=null @Synchronized fun getDatabase(context: Context): AppDatabase &amp;#123; instance?.let &amp;#123; return it &amp;#125; return Room.databaseBuilder(context.applicationContext, AppDatabase::class.java,\"app_database\") .allowMainThreadQueries()//Room默认不容许在主线程中进行数据库操作，加入这个方法可以在主线程进行数据库操作 .build().apply &amp;#123; instance =this &amp;#125; &amp;#125; &amp;#125; &amp;#125; &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"20dp\" android:orientation=\"vertical\" tools:context=\".room.RoomActivity\"> &lt;EditText android:id=\"@+id/edText\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"name 用空格隔开\" android:autofillHints=\"姓名\" android:inputType=\"text\" /> &lt;Button android:id=\"@+id/addBtn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/add\" /> &lt;Button android:id=\"@+id/queryBtn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/query_data\"/> &lt;Button android:id=\"@+id/updateBtn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/update\" /> &lt;Button android:id=\"@+id/deleteBtn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/delete\" /> &lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"> &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"> &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fontFamily=\"@font/aldrich\" android:textSize=\"20sp\" /> &lt;/LinearLayout> &lt;/ScrollView> &lt;/LinearLayout> class RoomActivity : AppCompatActivity() &amp;#123; //获取数据库实例 val userDao= AppDatabase.getDatabase(this).userDao() override fun onCreate(savedInstanceState: Bundle?) &amp;#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_room) addBtn.setOnClickListener &amp;#123; userDao.insertUser(User(edText.text.toString().split(\" \")[0],edText.text.toString().split(\" \")[1])) &amp;#125; updateBtn.setOnClickListener &amp;#123; userDao.upDateUser(User(edText.text.toString().split(\" \")[0],edText.text.toString().split(\" \")[1])) &amp;#125; deleteBtn.setOnClickListener &amp;#123; userDao.deleteUserByLastName(textView.text.toString()) &amp;#125; queryBtn.setOnClickListener &amp;#123; var str=\"\" for (user in userDao.getAll())&amp;#123; str+=user.toString()+\"\\n\" &amp;#125; textView.text=str &amp;#125; &amp;#125; &amp;#125; Room的数据库升级添加数据库表Book @Entity data class Book(var name:String,var pages: Int) &amp;#123; @PrimaryKey(autoGenerate = true) var id:Long=0 &amp;#125; BookDao @Dao interface BookDao &amp;#123; @Insert fun insertBook(book: Book):Long @Query(\"select * from Book\") fun loadAllBooks(): List&lt;Book> &amp;#125; //定义数据库对象，数据库版本，包含的实体类 //版本变成2 添加Book class @Database(version = 2, entities = [User::class,Book::class]) abstract class AppDatabase : RoomDatabase() &amp;#123; abstract fun userDao(): UserDao abstract fun bookDao(): BookDao companion object&amp;#123; private var instance: AppDatabase?=null val MIGRATION_1_2=object : Migration(1,2)&amp;#123; override fun migrate(database: SupportSQLiteDatabase) &amp;#123; database.execSQL(\"create table Book (\" + \"id integer primary key autoincrement not null,\" + \"name text not null,\" + \"pages integer not null)\") &amp;#125; &amp;#125; @Synchronized fun getDatabase(context: Context): AppDatabase &amp;#123; instance?.let &amp;#123; return it &amp;#125; return Room.databaseBuilder(context.applicationContext, AppDatabase::class.java,\"app_database\") .allowMainThreadQueries()//Room默认不容许在主线程中进行数据库操作，加入这个方法可以在主线程进行数据库操作 .addMigrations(MIGRATION_1_2)//添加数据表 .build().apply &amp;#123; instance =this &amp;#125; &amp;#125; &amp;#125; &amp;#125; WorkManager 调度任务使用 WorkManager API 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。 主要功能： 最高向后兼容到 API 14 在运行 API 23 及以上级别的设备上使用 JobScheduler 在运行 API 14-22 的设备上结合使用 BroadcastReceiver 和 AlarmManager 添加网络可用性或充电状态等工作约束 调度一次性或周期性异步任务 监控和管理计划任务 将任务链接起来 确保任务执行，即使应用或设备重启也同样执行任务 遵循低电耗模式等省电功能 WorkManager 旨在用于可延迟运行（即不需要立即运行）并且在应用退出或设备重启时必须能够可靠运行的任务。例如： 向后端服务发送日志或分析数据 定期将应用数据与服务器同步 WorkManager 不适用于应用进程结束时能够安全终止的运行中后台工作，也不适用于需要立即执行的任务。请查看后台处理指南，了解哪种解决方案符合您的需求。 WorkManger基本用法添加依赖def work_version = \"2.3.4\" // (Java only) implementation \"androidx.work:work-runtime:$work_version\" // Kotlin + coroutines implementation \"androidx.work:work-runtime-ktx:$work_version\" // optional - RxJava2 support implementation \"androidx.work:work-rxjava2:$work_version\" // optional - GCMNetworkManager support implementation \"androidx.work:work-gcm:$work_version\" // optional - Test helpers androidTestImplementation \"androidx.work:work-testing:$work_version\" 创建后台任务class SimpleWorker(context: Context,params: WorkerParameters): Worker(context,params) &amp;#123; override fun doWork(): Result &amp;#123; //耗时操作 Log.d(\"SimpleWorker\", \"doWork: do work in SimpleWorker\") return Result.success() &amp;#125; &amp;#125; button.setOnClickListener &amp;#123; val request=OneTimeWorkRequest.Builder(SimpleWorker::class.java) .setInitialDelay(5,TimeUnit.MINUTES)//设置5分钟后运行 .addTag(\"simple\")//添加请求标签， .build() WorkManager.getInstance(this).enqueue(request) &amp;#125; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/jetpack/"},{"title":"使用 ViewModel 处理配置更改","text":"使用 ViewModel 处理配置更改ViewModel 非常适合在用户积极使用应用程序时存储和管理与 UI 相关的数据。它允许快速访问 UI 数据，并帮助您避免通过旋转、窗口调整和其他常见发生的配置更改从网络或磁盘重新提取数据。若要了解如何实现视图模型，请参阅视图模型指南。 ViewModel 将数据保留在内存中，这意味着检索比从磁盘或网络中检索数据更便宜。ViewModel 与活动（或其他一些生命周期所有者）关联 - 它在配置更改期间保留在内存中，系统会自动将 ViewModel 与配置更改导致的新活动实例关联。 当用户退出活动或片段时，或者当您调用 finish（）时，ViewModels 会自动被系统销毁，这意味着状态将按用户在这些方案中的期望进行清除。 与保存的实例状态不同，ViewModels 在系统启动的进程死亡期间被销毁。这就是为什么您应该将 ViewModel 对象与 onSaveInstanceState（或其他一些磁盘持久性）结合使用，将标识符隐藏到保存的 InstanceState 中，以帮助查看模型在系统死亡后重新加载数据。 如果您已经拥有用于跨配置更改存储 UI 状态的内存中解决方案，则可能不需要使用 ViewModel。 博客 视图模型 ：一个简单的示例 视图模型：持久性、在保存状态（）、还原 UI 状态和加载器 Android 生命周期感知组件代码实验室 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/shi-yong-viewmodel-chu-li-pei-zhi-geng-gai/"},{"title":"视图导航","text":"[TOC] Navigation官方文档：https://developer.android.com/guide/navigation/ youtube教程视频：https://developer.android.com/guide/navigation/ 关键三部分 Navigation graph : 一个 XML 资源，其中包含一个集中位置中的所有与导航相关的信息。这包括应用内的所有单个内容区域（称为目标）以及用户可以通过应用可走的路径。 NavHost Fragment 显示导航图中的目的地的空容器。导航组件包含一个默认实现，即导航帧，显示片段目标。 NavController 管理中应用导航的对象。当用户在整个应用中移动时，协调中的目标内容的交换 开始使用Navigation 配置环境def nav_version = \"2.3.0\" // Kotlin implementation \"androidx.navigation:navigation-fragment-ktx:$nav_version\" implementation \"androidx.navigation:navigation-ui-ktx:$nav_version\" 创建几个BlankFragment 用于页面跳转 创建导航图 activity_main.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"> &lt;fragment android:id=\"@+id/nav_host_fragment\" &lt;!-- 关键代码 start--> android:name=\"androidx.navigation.fragment.NavHostFragment\" app:defaultNavHost=\"true\" app:navGraph=\"@navigation/nav_graph\" &lt;!-- 关键代码 end--> android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" /> &lt;/androidx.constraintlayout.widget.ConstraintLayout> 导航编辑器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/shi-tu-dao-hang/"},{"title":"基础学习","text":"安卓科特林基础知识包括以下课程： 第 1 课：构建第一个应用 官方Android开发者文档developer.android.com。 材料设计是一种概念设计理念，它概述了应用在移动设备上的外观和功能。材料设计不仅仅适用于 Android 应用程序。材料设计指南material.io。 Android Studio 为常见和推荐的应用程序和活动设计提供模板。这些模板为常见用例提供工作代码。 创建项目时，可以为第一个活动选择模板。 在开发应用时，可以从内置模板创建活动和其他应用组件。 Google 示例包含您可以学习、复制和合并到项目中的代码示例。 活动 MainActivity是 的子类，而子类又是 。是负责绘制 Android 应用 UI 和接收输入事件的核心 Android 类。AppCompatActivity``Activity``Activity 所有活动都有一个关联的布局文件，该文件是应用资源中的 XML 文件。布局文件为活动命名，例如 。activity_main.xml 中的 方法将布局与活动关联，并在创建活动时膨胀该布局。setContentView()``MainActivity 布局膨胀是将 XML 布局文件中定义的视图转换为（或”膨胀”成）Kotlin 在内存中的视图的过程。一旦布局膨胀发生，可以绘制这些对象到屏幕上，并动态修改它们。Activity 视图 应用布局中的所有 UI 元素都是 View 类的子类，称为视图。 和意见的例子。TextView``Button View元素可以分组在视图组中。视图组充当视图或其他视图组的容器。 是线性排列其视图的视图组的示例。LinearLayout 查看属性 和 属性指示视图的宽度和高度。该值将视图拉伸到其父视图的宽度或高度。该值将缩小视图以适合视图的内容。android:layout_width``android:layout_height``match_parent``wrap_content 属性指示视图应显示的文本（如果该视图显示文本）。对于按钮，是按钮标签。android:text``android:text 视图组中的属性排列它包含的视图元素。从左到右排列视图的值。从上到下排列视图的值。android:orientation``LinearLayout``horizontal``vertical 属性确定视图的位置以及该视图的所有子元素。android:layout_gravity 该属性定义文本视图中文本的大小。文本大小以 sp 单位（可伸缩像素）指定。通过使用 sp 单位，您可以独立于设备的显示质量调整文本的大小。android:textSize 字符串 在布局中硬编码字符串，最好使用字符串资源。 文件中包含字符串资源。values/res/string.xml 要提取字符串，请使用 （在 Mac 上）。选择从弹出式菜单中提取字符串资源。Alt+Enter``Option+Enter 使用视图 若要将 Kotlin 代码连接到布局中定义的视图，需要在视图膨胀后获取对视图对象的引用。将 ID （） 分配给布局中的视图，然后使用findViewById（）方法获取关联的视图对象。android:id 当您在 XML 布局文件中为视图创建 ID 时，Android Studio 会在生成的类中使用该 ID 的名称创建整数常量。然后可以在 方法中使用该引用。R``R.id``findViewById() 您可以直接按属性名称在 Kotlin 代码中设置视图对象的属性。例如，文本视图中的文本由 XML 中的属性定义，并且由 Kotlin 中的属性定义。android:text``text 单击处理程序是当用户单击或点击 UI 元素时调用的方法。若要将单击处理程序方法附加到视图（如按钮），请使用 方法。setOnClickListener() 使用烤面包Toast 是一种视图，在一个小的弹出窗口中向用户显示一条简单的消息。 若要创建 Toast，请使用[三个参数在](https://developer.android.com/reference/android/widget/Toast.html#makeText(android.content.Context, int, int))Toast 类上调用makeText（）工厂方法： 应用的上下文Activity 要显示的消息，例如字符串资源 持续时间，例如Toast.LENGTH_SHORT 要显示 Toast，请调用 。show() 第 2 课：布局Android 开发人员文档： 布局 ViewGroup View 线性布局 ScrollView 支持不同的像素密度（dp） 使用布局编辑器构建 UI 安卓工作室文档 样式和主题 1. 输入框及事件监听 Android工作室中的布局编辑器工具是一个可视化设计编辑器。您可以使用布局编辑器通过将 UI 元素拖动到布局中来构建应用的布局。 EditText是允许用户输入和修改文本的 UI 元素。 按钮是用户可以点击执行操作的 UI 元素。按钮可以由文本、图标或文本和图标组成。 单击侦听器 您可以通过向点击侦听器添加单击侦听器来对被点击做出任何响应。View 定义单击侦听器的函数接收被单击的 。View 可以通过两种方式之一将单击侦听器函数附加到 ：View 在 XML 布局中，将android：onClick属性添加到*View*元素。&lt;``&gt; 以编程方式，在相应的 中使用setOnClickListener（View.OnClickListener）函数。Activity 2. 使用布局编辑器约束布局 ConstraintLayout官方教程：https://codelabs.developers.google.com/codelabs/kotlin-android-training-constraint-layout/index.html#3 3. 数据绑定基础知识Android studio 4.0实现了自动绑定 id 可以直接使用idapply plugin: 'kotlin-android-extensions' 使用数据绑定替换对 的调用的步骤：findViewById() 在文件的 Android 部分启用数据绑定：build.gradledataBinding { enabled = true } 用作 XML 布局中的根视图。&lt;layout&gt; 定义绑定变量：private lateinit var binding: ActivityMainBinding 在 中创建绑定对象，替换 ：MainActivity``setContentViewbinding = DataBindingUtil.setContentView(this, R.layout.activity_main) 将 的调用替换为对绑定对象中视图的引用。例如：（在示例中，视图的名称从 XML 中的视图生成骆驼大小写。findViewById()``findViewById&lt;Button&gt;(R.id.done_button)``binding.doneButton``id 将视图绑定到数据的步骤： 为数据创建数据类。 在标记内添加块。&lt;data&gt;``&lt;layout&gt; 定义 具有名称的类型，以及作为数据类的类型。&lt;variable&gt; &lt;data&gt; &lt;variable name=\"myName\" type=\"com.example.android.aboutme.MyName\" /&gt; &lt;/data&gt; 在 中，使用数据类的实例创建一个变量。例如：MainActivityprivate val myName: MyName = MyName(\"Aleks Haecky\") 在绑定对象中，将变量设置为刚刚创建的变量：binding.myName = myName 在 XML 中，将视图的内容设置为在块中定义的变量。使用点符号访问数据类内的数据。&lt;data&gt;android:text=\"@={myName.name}\" 第 3 课：导航1. 创建片段(Fragment)fragment生命周期 2. 定义导航路径3. 启动外部活动第 4 课：活动和片段生命周期4.1生命周期和日志记录 AS快捷键ctrl+o（选择方法，重写） 生命周期函数 说明 注意 onCreate() 活动执行任何一次初始化 该方法是重写，因此在它里面，必须立即调用 。其他生命周期方法也是如此。onCreate()``super.onCreate() onStart（） 生命周期方法在 刚刚调用。运行后，您的活动在屏幕上可见。与 不同，在活动的生命周期中，可以多次调用（仅调用一次以初始化活动） 注意，它与相应的生命周期方法配对。如果用户启动应用，然后返回到设备主屏幕，则活动将停止，并且不再在屏幕上可见。onStart()``onStop() onResume() 为活动提供焦点，并准备好让用户与其进行交互。 onPause() 应用不再在屏幕上可见 onRestart() 活动返回到前台 onStop() 停止活动 onDestroy() 应用销毁 片段的整个启动生命周期，包括这些回调： onAttach()：当片段与其所有者活动关联时调用。 onCreate()：与活动类似，对于片段，调用执行初始片段创建（布局除外）。onCreate()``onCreate() onCreateView()：调用以膨胀片段的布局。 onActivityCreated()：当所有者活动完成时调用。在调用此方法之前，您的片段将无法访问该活动。onCreate() onStart()：当片段变为可见时调用;与活动的平行。onStart() onResume()：当片段获得用户焦点时调用;与活动的平行。onResume() Log 类将消息写入日志猫。此命令有三个部分： 日志消息的严重性，即消息的重要程度。在这种情况下[，Log.i（） 方法](https://developer.android.com/reference/kotlin/android/util/Log#i(kotlin.String, kotlin.String))写入信息消息。类中的其他方法包括[用于错误的 Log.e（）](https://developer.android.com/reference/kotlin/android/util/Log#e(kotlin.String, kotlin.String))或用于[警告的 Log.w（）。 ](https://developer.android.com/reference/kotlin/android/util/Log#w(kotlin.String, kotlin.String))Log 日志标记，在这种情况下。标记是一个字符串，可让您更轻松地在 Logcat 中查找日志消息。标记通常是类的名称。\"MainActivity\" 实际日志消息，一个短字符串，在这种情况下是 。\"onCreate called\" 编译并运行甜品点击器应用程序。点击甜点时，不会看到应用程序中的任何行为差异。在 Android 工作室中， 在屏幕底部， 单击Logcat选项卡 。日志猫是记录消息的控制台。此处将显示来自 Android 的有关应用的消息，包括您用方法或其他类方法显式发送到日志的消息。Log.i()``Log 在**”日志猫**”窗格中，键入搜索字段。 Logcat可以包含许多消息，其中大多数对您没有用。 您可以通过多种方式筛选 Logcat 条目，但搜索是最容易的。由于您将用作代码中的日志标记，因此可以使用该标记筛选日志。在开始添加意味着这是一个信息性消息，由 创建。日志消息包括日期和时间、包 （）、日志标记（在开始时使用）和实际消息。由于此消息出现在日志中，因此您知道已执行。I/MainActivity``MainActivity``I/``Log.i()``com.example.android.dessertclicker``I/``onCreate() 使用第三方库，显示时间日志implementation 'com.jakewharton.timber:timber:4.7.1' 简介：Timber使用 类，因为整个应用将使用此日志记录库，并且在设置其他所有内容之前，需要先初始化一次库。在这种情况下，您可以对类进行子类，并使用您自己的自定义实现重写默认值。Application``Application 在全局类里初始化Timber.plant(Timber.DebugTree()) 使用Timber.i(\"onCreate called\") 4.2复杂的生命周期情况生命周期提示 如果在生命周期回调中设置或启动某项内容，请停止或删除相应回调中的东西。通过停止它，你确保它不会继续运行时，它不再需要。例如，如果在 中设置计时器，则需要在 中暂停或停止计时器。onStart()``onStop() 仅用于初始化应用首次启动时运行一次的应用部分。用于启动应用在应用启动时和每次应用返回前台时运行的应用部分。onCreate()``onStart() 生命周期库 使用 Android 生命周期库将生命周期控制从活动或片段转移到需要生命周期感知的实际组件。 生命周期所有者是具有（因此具有”拥有”）生命周期（包括 和 ）的组件。生命周期所有者实现接口。Activity``Fragment``LifecycleOwner 生命周期观察者会关注当前生命周期状态，并在生命周期更改时执行任务。生命周期观察者实现接口。LifecycleObserver Lifecycle对象包含实际的生命周期状态，并在生命周期更改时触发事件。 要创建生命周期感知类，请： 在需要生命周期感知的类中实现接口。LifecycleObserver 使用活动或片段中的生命周期对象初始化生命周期观察者类。 在生命周期观察者类中，注释生命周期感知方法，并注明它们感兴趣的生命周期状态更改。 例如，注释指示该方法正在监视生命周期事件。@OnLifecycleEvent(Lifecycle.Event.ON_START)``onStart 进程关闭和保存活动状态 Android 可调节在后台运行的应用，以便前台应用可以毫无问题地运行。此法规包括限制后台应用可以执行的处理量，有时甚至会关闭整个应用过程。 用户无法判断系统是否在后台关闭了应用。应用仍显示在”最近”屏幕中，并且应以用户离开时的状态重新启动。 Android 调试桥 （） 是一个命令行工具，允许您向连接到计算机的模拟器和设备发送指令。您可以使用 模拟应用中的进程关闭。adb``adb 当 Android 关闭应用进程时，不会调用生命周期方法。应用程序刚刚停止。onDestroy() 保留活动和片段状态 当你的应用进入后台时，在调用后，应用数据将保存到捆绑包中。某些应用数据（如 的内容）会自动保存。onStop()``EditText 捆绑包是 的实例，它是键和值的集合。键始终为字符串。Bundle 使用回调将其他数据保存到要保留的捆绑包，即使应用已自动关闭。若要将数据放入捆绑包中，请使用 以 开始的捆绑方法，例如 。onSaveInstanceState()``put``putInt() 可以从方法中的捆绑包中恢复数据，或者更常见地在 中获取数据。该方法具有保存捆绑包的参数。onRestoreInstanceState()``onCreate()``onCreate()``savedInstanceState 如果变量包含 ，则活动在没有状态包的情况下启动，并且没有要检索的状态数据。savedInstanceState``null 若要使用键从捆绑包中检索数据，请使用 以 开始的方法，如 。Bundle``get``getInt() 配置更改 当设备的状态发生如此急剧的变化，系统解决更改的最简单方法是关闭和重建活动时，就会发生配置更改。 配置更改的最常见示例是当用户将设备从纵向旋转到横向模式或从横向模式旋转到纵向模式时。当设备语言更改或插入硬件键盘时，也可能发生配置更改。 当发生配置更改时，Android 会调用所有活动生命周期的关闭回调。然后 Android 从头开始重新启动活动，运行所有生命周期启动回调。 当 Android 由于配置更改而关闭应用时，它将使用 可用的状态捆绑包重新启动活动。onCreate() 与进程关闭一样，将应用的状态保存到 中的捆绑包。onSaveInstanceState() 第 5 课：体系结构组件第 6 课：房间数据库和密码第 7 课：回收器视图第8课：连接到互联网第 9 课：存储库第 10 课：为每个人设计 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/android-xue-xi/ji-chu-xue-xi/"},{"title":"1-2 连接SSH","text":"[toc] 1.首先修改密码修改虚拟机的默认登录密码 虚拟机控制台的默认登录密码在启动时显示，如下所示： 首次登录时，系统会自动提示您更改此更改。若要以后更改它，请执行下面的命令在控制台： passwd 2.启用 SSH 服务器 默认情况下，在 Bitnami 虚拟机中禁用 SSH 服务器。但是，某些应用程序（如 GitLab）需要 SSH 访问导入代码存储库。 Debiansudo rm -f /etc/ssh/sshd_not_to_be_run sudo systemctl enable ssh sudo systemctl start ssh Ubuntusudo mv /etc/init/ssh.conf.back /etc/init/ssh.conf sudo start ssh 禁用 SSH 服务器默认情况下，在 Bitnami 虚拟机中禁用 SSH 服务器。如果已按照此处所述启用它，则可以按照相反的步骤禁用它： Debiansudo systemctl stop ssh sudo systemctl disable ssh Ubuntusudo stop ssh sudo mv /etc/init/ssh.conf /etc/init/ssh.conf.back 3.连接成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/bitnami-xu-ni-ji/1-2-lian-jie-ssh/"},{"title":"1-3 安装桌面","text":"[toc] 启用桌面访问文件下载很慢,(不推荐) 若要允许位纳米用户的桌面访问，请按照以下步骤操作： Debian 安装侏儒核心包： sudo apt-get update sudo apt-get install gnome-core 重新启动计算机。 现在，您应该能够以bitnami 用户位登录到桌面。 Ubuntu 安装ubuntu 桌面包： sudo apt-get update sudo apt-get install ubuntu-desktop 创建一个名为*/usr/共享/光德姆/光德姆.conf.d/60-bitnami.conf 的新文件*，并添加如下行： [SeatDefaults] default-user=bitnami greeter-show-manual-login=true 您可以通过执行以下命令来创建该文件： sudo sh -c 'echo \"[SeatDefaults]\\ndefault-user=bitnami\\ngreeter-show-manual-login=true\" &gt; /usr/share/lightdm/lightdm.conf.d/50-bitnami.conf' 重新启动虚拟机。 现在，您应该能够以bitnami 用户位登录到桌面。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/bitnami-xu-ni-ji/1-3-an-zhuang-zhuo-mian/"},{"title":"2-1文档学习","text":"[toc] 官方文档地址:https://docs.bitnami.com/virtual-machine/get-started-virtualbox/ 简介 如果您曾经尝试过安装服务器应用程序（如 WordPress）或开发环境（如 Apache/PHP/MySQL 环境），您已经知道它比乍看起来要困难得多。有文件要下载和复制，配置设置要调整，和各种其他箍跳转之前，你可以真正得到一些富有成效的工作。 Bitnami 虚拟机 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/bitnami-xu-ni-ji/2-1-wen-dang-xue-xi/"},{"title":"简介","text":"BitNami 提供wordpress、joomla、drupal、bbpress等开源程序的傻瓜式安装包下载，所有的安装包内置了服务器环境，就是说，不需要在本地电脑上另外搭建服务器，就可以一次性傻瓜式安装完毕。BitNami开源PHP程序傻瓜集成安装包可选环境，包括WAMP，LAMP，MAMP和SAMP。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/bitnami-xu-ni-ji/jian-jie/"},{"title":"1-2-常用操作","text":"启动docker查看容器查看当前运行的容器docker ps 查看所有容器docker ps -a 在查看容器时，涉及到几个查看参数，含义分别如下： CONTAINER ID:CONTAINER ID是指容器的id，是一个唯一标识符,这是一个64位的十六进制整数，在不会混淆的情况下可以只采用id的前几位进行\b标识一个容器。 IMAGE:IMAGE表示创建容器时使用的镜像。 COMMAND:COMMAND表示容器最后运行的命令。 CREATED:创建容器的时间。 STATUS:容器的状态，这里可能显示一个容器启动时间，也能显示容器关闭时间。具体显示哪个要看容器当前的状态。 PORTS:容器对外开放的端口。 NAMES:容器的名字，如果不设置，会有一个默认的名字。 查看最新创建的容器docker ps -l 查看最新创建的n个容器 docker ps -n=xxx 创建容器容器创建 docker create nginx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/docker-xue-xi/1-2-chang-yong-cao-zuo/"},{"title":"1-2 使用教程","text":"GitBook 简介GitBook 官网 GitBook 文档 GitBook 准备工作安装 Node.jsGitBook 是一个基于 Node.js 的命令行工具，下载安装 Node.js，安装完成之后，你可以使用下面的命令来检验是否安装成功。 $ node -v v7.7.1 安装 GitBook输入下面的命令来安装 GitBook。 $ npm install gitbook-cli -g 安装完成之后，你可以使用下面的命令来检验是否安装成功。 $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 更多详情请参照 GitBook 安装文档 来安装 GitBook。 安装 GitBook 编辑器去 GitBook 官网 下载 GitBook 编辑器；如果是 Mac 用户且安装过 brew cask 的话可以使用 brew cask install gitbook-editor 命令行来安装 GitBook 编辑器。 先睹为快GitBook 准备工作做好之后，我们进入一个你要写书的目录，输入如下命令。 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished 可以看到他会创建 README.md 和 SUMMARY.md 这两个文件，README.md 应该不陌生，就是说明文档，而 SUMMARY.md 其实就是书的章节目录，其默认内容如下所示： # Summary * [Introduction](README.md) 接下来，我们输入 $ gitbook serve 命令，然后在浏览器地址栏中输入 http://localhost:4000 便可预览书籍。 效果如下所示： 运行该命令后会在书籍的文件夹中生成一个 _book 文件夹, 里面的内容即为生成的 html 文件，我们可以使用下面命令来生成网页而不开启服务器。 gitbook build 下面我们来详细介绍下 GitBook 目录结构及相关文件。 目录结构GitBook 基本的目录结构如下所示： . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md 下面我们主要来讲讲 book.json 和 SUMMARY.md 文件。 book.json该文件主要用来存放配置信息，我先放出我的配置文件。 &amp;#123; \"title\": \"Blankj's Glory\", \"author\": \"Blankj\", \"description\": \"select * from learn\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"styles\": &amp;#123; \"website\": \"/styles/website.css\" &amp;#125;, \"structure\": &amp;#123; \"readme\": \"README.md\" &amp;#125;, \"links\": &amp;#123; \"sidebar\": &amp;#123; \"我的狗窝\": \"https://blankj.com\" &amp;#125; &amp;#125;, \"plugins\": [ \"-sharing\", \"splitter\", \"expandable-chapters-small\", \"anchors\", \"github\", \"github-buttons\", \"donate\", \"sharing-plus\", \"anchor-navigation-ex\", \"favicon\" ], \"pluginsConfig\": &amp;#123; \"github\": &amp;#123; \"url\": \"https://github.com/Blankj\" &amp;#125;, \"github-buttons\": &amp;#123; \"buttons\": [&amp;#123; \"user\": \"Blankj\", \"repo\": \"glory\", \"type\": \"star\", \"size\": \"small\", \"count\": true &amp;#125; ] &amp;#125;, \"donate\": &amp;#123; \"alipay\": \"https://blankj.com/gitbook/source/images/donate.png\", \"title\": \"\", \"button\": \"赞赏\", \"alipayText\": \" \" &amp;#125;, \"sharing\": &amp;#123; \"douban\": false, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": false, \"qzone\": false, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": false, \"whatsapp\": false, \"all\": [ \"google\", \"facebook\", \"weibo\", \"twitter\", \"qq\", \"qzone\", \"linkedin\", \"pocket\" ] &amp;#125;, \"anchor-navigation-ex\": &amp;#123; \"showLevel\": false &amp;#125;, \"favicon\":&amp;#123; \"shortcut\": \"./source/images/favicon-32x32.webp\", \"bookmark\": \"./source/images/favicon-32x32.webp\", \"appleTouch\": \"./source/images/apple-touch-icon.webp\" &amp;#125; &amp;#125; &amp;#125; 相信很多节点自己也能猜到是什么意思，我还是简单介绍下吧。 title本书标题 author本书作者 description本书描述 language本书语言，中文设置 “zh-hans” 即可 gitbook指定使用的 GitBook 版本 styles自定义页面样式 structure指定 Readme、Summary、Glossary 和 Languages 对应的文件名 links在左侧导航栏添加链接信息 plugins配置使用的插件 pluginsConfig配置插件的属性 SUMMARY.md这个文件主要决定 GitBook 的章节目录，它通过 Markdown 中的列表语法来表示文件的父子关系，下面是一个简单的示例： # Summary * [Introduction](README.md) * [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) * [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 这个配置对应的目录结构如下所示: 我们通过使用 标题 或者 水平分割线 将 GitBook 分为几个不同的部分，如下所示： # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) --- * [Last part without title](part3/title.md) 这个配置对应的目录结构如下所示: 插件GitBook 有 插件官网，默认带有 5 个插件，highlight、search、sharing、font-settings、livereload，如果要去除自带的插件， 可以在插件名称前面加 -，比如： \"plugins\": [ \"-search\" ] 如果要配置使用的插件可以在 book.json 文件中加入即可，比如我们添加 plugin-github，我们在 book.json 中加入配置如下即可： &amp;#123; \"plugins\": [ \"github\" ], \"pluginsConfig\": &amp;#123; \"github\": &amp;#123; \"url\": \"https://github.com/your/repo\" &amp;#125; &amp;#125; &amp;#125; 然后在终端输入 gitbook install ./ 即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/gitbook-xue-xi/1-2-shi-yong-jiao-cheng/"},{"title":"2-1 配置主题","text":"hexo-theme-matery 这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 支持 DaoVoice、Tidio 在线聊天功能。 下载当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: git clone https://github.com/blinkfox/hexo-theme-matery.git 配置切换主题修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2018-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2018-09-30 17:25:30 type: \"about\" layout: \"about\" --- 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2018-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2018-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [&amp;#123; \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" &amp;#125;, &amp;#123; \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" &amp;#125;, &amp;#123; \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" &amp;#125;] 新建 404 页如果在你的博客 source 目录下还没有 404.md 文件，那么你就需要新建一个 编辑你刚刚新建的页面文件 /source/404.md，至少需要以下内容： --- title: 404 date: 2018-09-30 17:25:30 type: \"404\" layout: \"404\" description: \"Oops～，我崩溃了！找不到你想要的页面 :(\" --- 菜单导航配置配置基本菜单导航的名称、路径url和图标icon.1.菜单导航名称可以是中文也可以是英文(如：Index或主页) 2.图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)2.在children下创建二级菜单的 名称name,路径url和图标icon.3.注意每个二级菜单模块前要加 -.4.注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： highlight: enable: false prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 中文链接转拼音（建议安装）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) &amp;#123; %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% &amp;#125; %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： # 是否在首页显示音乐 music: enable: true title: # 非吸底模式有效 enable: true show: 听听音乐 server: netease # require music platform: netease, tencent, kugou, xiami, baidu type: playlist # require song, playlist, album, search, artist id: 503838841 # require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐）， baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id`获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，`playlist`的`id 即为这串数字。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/github-xue-xi/chuang-jian-ge-ren-bo-ke/hexo/2-1-pei-zhi-zhu-ti/"},{"title":"junit简介","text":"什么是 JUnit？JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。 JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。 什么是Junit5?与以前的JUnit版本不同，JUnit 5由来自三个不同子项目的几个不同模块组成。 JUnit 5 = JUnit平台 + JUnit Jupiter + JUnit Vintage 特点：JUnit 是一个开放的资源框架，用于编写和运行测试。提供注释来识别测试方法。提供断言来测试预期结果。提供测试运行来运行测试。JUnit 测试允许你编写代码更快，并能提高质量。JUnit 优雅简洁。没那么复杂，花费时间较少。JUnit 测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。JUnit 测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。JUnit 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。 测试工具测试工具是一整套固定的工具用于基线测试。测试工具的目的是为了确保测试能够在共享且固定的环境中运行，因此保证测试结果的可重复性。它包括： 在所有测试调用指令发起前的 setUp() 方法。在测试方法运行后的 tearDown() 方法。 测试套件测试套件意味捆绑几个测试案例并且同时运行。在 JUnit 中，@RunWith 和 @Suite 都被用作运行测试套件。 注解 注解 描述 @Test 表示方法是测试方法。与JUnit 4的@Test注释不同，此注释不声明任何属性，因为JUnit Jupiter中的测试扩展基于其自己的专用注释进行操作。除非重写这些方法，否则它们将被继承。 @ParameterizedTest 表示方法是参数化测试。除非重写这些方法，否则它们将被继承。 @RepeatedTest 表示方法是重复测试的测试模板。除非重写这些方法，否则它们将被继承。 @TestFactory 表示方法是动态测试的测试工厂。除非重写这些方法，否则它们将被继承。 @TestTemplate 表示方法是测试用例的模板，测试用例设计为根据已注册提供程序返回的调用上下文的数量被多次调用。除非重写这些方法，否则它们将被继承。 @TestMethodOrder 用于为带注释的测试类配置测试方法的执行顺序；类似于JUnit 4的@FixMethodOrder。这样的注释是继承的。 @TestInstance 用于为带注释的测试类配置测试实例生命周期。这样的注释是继承的。 @DisplayName 声明测试类或测试方法的自定义显示名称。这样的注释不是继承的。 @DisplayNameGeneration 声明测试类的自定义显示名称生成器。这样的注释是继承的。 @BeforeEach 表示该注释的方法应该被执行之前 的每个 @Test，@RepeatedTest，@ParameterizedTest，或@TestFactory方法在当前类; 类似于JUnit 4的@Before。除非重写这些方法，否则它们将被继承。 @AfterEach 表示该注释的方法应该被执行之后 每个 @Test，@RepeatedTest，@ParameterizedTest，或@TestFactory方法在当前类; 类似于JUnit 4的@After。除非重写这些方法，否则它们将被继承。 @BeforeAll 表示该注释的方法应该被执行之前 所有 @Test，@RepeatedTest，@ParameterizedTest，和@TestFactory方法在当前类; 类似于JUnit 4的@BeforeClass。此类方法是继承的（除非它们被隐藏或覆盖），并且必须被继承（除非static使用“每类” 测试实例生命周期）。 @AfterAll 表示该注释的方法应该被执行之后 的所有 @Test，@RepeatedTest，@ParameterizedTest，和@TestFactory方法在当前类; 类似于JUnit 4的@AfterClass。此类方法是继承的（除非它们被隐藏或覆盖），并且必须被继承（除非static使用“每类” 测试实例生命周期）。 @Nested 表示带注释的类是一个非静态的嵌套测试类。@BeforeAll和@AfterAll方法不能直接在使用@Nested测试类除非“每级” 测试实例的生命周期被使用。这样的注释不是继承的。 @Tag 用于在类或方法级别声明用于过滤测试的标签；类似于TestNG中的测试组或JUnit 4中的类别。此类注释在类级别继承，而不在方法级别继承。 @Disabled 用于禁用测试类或测试方法；类似于JUnit 4的@Ignore。这样的注释不是继承的。 @Timeout 如果执行超过给定的持续时间，则使测试，测试工厂，测试模板或生命周期方法失败。这样的注释是继承的。 @ExtendWith 用于声明性地注册扩展。这样的注释是继承的。 @RegisterExtension 用于通过字段以编程方式注册扩展。除非被遮盖，否则这些字段将被继承。 @TempDir 用于通过生命周期方法或测试方法中的字段注入或参数注入来提供临时目录；位于org.junit.jupiter.api.io包装中。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/junit/junit-jian-jie/"},{"title":"linux常用命令","text":"linux常用命令软件操作命令软件包管理 yum安装软件 yum install xxx卸载软件 yum remove xxx搜索软件 yum serach xxx清理缓存 yum clean packages列出已安装 yum list软件包信息 yum info xxx服务器硬件资源和磁盘操作内存：free -m硬盘：df -h负载：w/top文件和文件夹操作命令linux文件的目录结构 根目录 / 家目录 /home 临时目录 /tmp 配置目录 /etc 用户程序目录 /usr 文件基本操作 ls 查看目录下文件 touch 新建文件 mkdir 新建文件夹 cd 进入目录 rm 删除文件或目录 cp 复制 mv 移动 pwd 显示路径 文本编辑神器Vim Vim安装 yum install vim 文件权限 421 r=4 w=2 x=1 文件搜索 查找 读取 tail 尾部读取 head 头部读取 cat 读取整个文件 more 分页读取 less 可控分页 grep 搜索关键字 find 查找 可以去菜鸟教程学习 wc 统计个数 文件解压 压缩 tar –cvf jpg.tar *.jpg // 将目录里所有jpg文件打包成 tar.jpg tar –czf jpg.tar.gz *.jpg // 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz tar –cjf jpg.tar.bz2 *.jpg // 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为jpg.tar.bz2 tar –cZf jpg.tar.Z *.jpg // 将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg // rar格式的压缩，需要先下载 rar for linux zip jpg.zip *.jpg // zip格式的压缩，需要先下载 zip for linux 解压 tar –xvf file.tar // 解压 tar 包 tar -xzvf file.tar.gz // 解压 tar.gz tar -xjvf file.tar.bz2 // 解压 tar.bz2 tar –xZvf file.tar.Z // 解压 tar.Z unrar e file.rar // 解压 rar unzip file.zip // 解压 zip 总结 1、*.tar 用 tar –xvf 解压 2、*.gz 用 gzip -d或者gunzip 解压 3、*.tar.gz和*.tgz 用 tar –xzf 解压 4、*.bz2 用 bzip2 -d或者用bunzip2 解压 5、*.tar.bz2用tar –xjf 解压 6、*.Z 用 uncompress 解压 7、*.tar.Z 用tar –xZf 解压 8、*.rar 用 unrar e解压 9、*.zip 用 unzip 解压 系统用户操作命令useradd 添加用户adduser 添加用户userdel 删除用户passwd 设置密码防火墙相关设置简介 作用：保护服务器安全 设置防火墙 开放80，22端口 关闭防火墙 设置防火墙命令 安装：yum install firewalld 启动：service firewalld start 状态：service firewalld status 关闭或禁用：service firewalld stop/disable 提权操作sudo 和文件传输操作提权：sudo visudo：将普通用户添加到root信任列表中 文件下载 wget ，curl 文件上传 scp XMind - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/linux-chang-yong-ming-ling/"},{"title":"MyBatis框架","text":"MyBatis框架mybatis入门mybatis的概述 java持久层框架 封装了jdbc 等复杂的数据库操作 通过xml或注解的方式将要执行的statement配置 通过java对象和statement中的sql动态参数进行映射生成sql语句，并将结果映射为java对象并返回 采用ORM（Object Relational Mapping 对象关系映射）思想 实体–数据库–映射 环境搭建 第一步：创建maven工程并导入依赖pom.xml org.mybatis mybatis 3.4.5 mysql mysql-connector-java 8.0.12 log4j log4j 1.2.17 第二步：创建实体类和dao接口 第三步：创建mybatis的主配置文件SqlMapConfig.xml 第四步：创建映射配置文件IUserDao.xml 环境搭建注意事项 第一个：创建IUserDao.xml和IUserDao.java时名称保持一致 第二个：xml文件目录要逐个创建，进行分层 第三个：mybatis的配置文件必须包接口一致 第四个：映射文件的mapper标签namsespace属性值必须是dao接口的全类名 第五个：映射配置文件的配置操作。id属性取值必须是dao接口的方法名 入门案例//1.读取配置文件String resource = “mybatis-config.xml”;InputStream inputStream = Resources.getResourceAsStream(resource); //2.创建SqlSessionFactory工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //3.使用工厂生产SqlSession对象SqlSession sqlSession=sqlSessionFactory.openSession();//4.使用SqlSession创建Dao接口代理对象IUserDao userDao=sqlSession.getMapper(IUserDao.class);//5.使用代理对象执行方法List all = userDao.findAll();for (User user : all) { System.out.println(user.toString());}//6.释放资源sqlSession.close();inputStream.close(); mybatis基于注解的入门案例 把IUserDao.xml移除，在dao接口上使用@Select注解，并指向SQL语句 SqlMapperConfig.xml中mapper配置时，使用class属性指定dao接口全类名 自定义mybatis框架分析 Mybatis 在使用代理dao的方式实现增删改查时做什么事呢 第一：创建代理对象 第二：在代理对象中调用selectList mybatis基本使用mybatis的单表crud操作mybatis的参数和返回值mybatis的dao编写mybatis配置的细节 几个标签的使用mybatis深入和多表mybatis的连接池mybatis的事务控制及设计的方法mybatis的多表查询 一对多 多 对多 XMind - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/mybatis-kuang-jia/"},{"title":"Spring入门","text":"Spring入门课程概述IOC介绍ioc概念介绍 控制反转 控制对象的创建及销毁（生命周期） 将对象的控制权交给ioc容器 Springioc入门Bean实例化和注入实例化Bean的方式介绍注入Bean的方式介绍Bean的作用域singletonweb相关作用域自定义作用域Bean的懒加载Bean的初始和销毁逻辑处理Bean属性继承SpringIoc注解注解的基本介绍使用通过注解注入Bean通过注解设定Bean的作用域通过注解开启Bean的懒加载通过注解编写Bean初始化及销毁逻辑处理XMind - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/spring-ru-men/"},{"title":"多线程编程","text":"多线程编程进程与线程多线程的两种实现方式线程的基本操作多线程同步与死锁synchronized同步实现操作Object类对多线程的支持线程生命周期XMind - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/duo-xian-cheng-bian-cheng/"},{"title":"字节流与字符流","text":"字节流与字符流字节流与字符流区别 OutputStream字节输出流字节(byte)是进行i/o操作的基本数据单位Writer字符输出流Reader字符输入流转换流案例XMind - Trial Version document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/java-web/zi-jie-liu-yu-zi-fu-liu/"},{"title":"1-1-安装","text":"Redis安装方式官网：https://redis.io/ 官方文档：https://redis.io/documentation 编译安装(直接，不过gcc环境太麻烦，还容易出错) 准备好gcc环境yum install -y cpp yum install -y binutils yum install -y glibc yum install -y glibc-kernheaders yum install -y glibc-common yum install -y glibc-devel yum install -y gcc yum install -y make # 升级gcc yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash 下载， 解压，编译，安装 wget http://download.redis.io/releases/redis-6.0.5.tar.gz tar xzf redis-6.0.5.tar.gz cd redis-6.0.5 make # 注意 如果提示错误 In file included from adlist.c:34:0: zmalloc.h:50:31: fatal error: jemalloc/ # 执行 make MALLOC=libc make install 运行redis-server redis.conf 使用Docker安装（提前安装运行docker） docker pull redis 创建配置文件当前目录下创建redis文件夹,redis目录下创建 redis.conf redis.conf 设置配置信息 #修改为守护模式 daemonize yes #设置进程锁文件 pidfile redis/redis.pid #端口 port 6379 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile redis/log-redis.log #设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid>命令在连接上指定数据库id databases 8 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save &lt;seconds> &lt;changes> #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， #可以关闭该#选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump.rdb #指定本地数据库路径 dir redis/db/ #指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能 #会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有 #的数据会在一段时间内只存在于内存中 appendonly no #指定更新日志条件，共有3个可选值： #no：表示等操作系统进行数据缓存同步到磁盘（快） #always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） #everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec #redis配置外网访问： protected-mode no #配置密码 requirepass root 运行容器docker run -p 6379:6379 --name redis -v $PWD/redis.conf:/root/redis/redis.conf -v $PWD/data:/root/redis/data -d redis redis-server 进入容器并开启客户端查看redis信息docker exec -it myredis redis-cli document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/1-1-an-zhuang/"},{"title":"入门基础学习","text":"[TOC] 1. 编程的基础知识1.1 Hello Worldfun main() &amp;#123; println(\"Hello, world!\") &amp;#125; println()需要单个参数，即 。通过将字符放在引号内来定义 。显示光标的参数后，将光标移动到新行，因此后续输出将显示在下一行 1.2 常量值定义var &amp; valvar: 可变的值 val:只能初始化，不能被重新分配 1.3 函数 fun函数结合了一组活动，是组织程序和重新使用代码的最基本方法。 将信息传递到函数中，该函数使用该信息来计算和生成结果。函数的基本形式是： fun 方法名（参数：类型，参数：类型）：返回类型{ ​ 代码 ​ retrun 结果 } fun functionName(p1: Type1, p2: Type2, ...): ReturnType &amp;#123; lines of code return result &amp;#125; 1.4 if表达式关键字测试表达式以查看它是否是 或 以及根据结果执行操作。真假的表达叫做布尔 fun main() &amp;#123; if (1 > 0) println(\"It's true!\") if (10 &lt; 11) &amp;#123; println(\"10 &lt; 11\") println(\"ten is less than eleven\") &amp;#125; &amp;#125; /* Output: It's true! 10 &lt; 11 ten is less than eleven */ 1.5 字符串模板模板会将该标识符的内容插入到 ：$``String``String fun main() &amp;#123; val answer = 42 println(\"Found $answer!\") // [1] println(\"printing a $1\") // [2] &amp;#125; /* Output: Found 42! printing a $1 */ 将表达式放在内部将对其进行计算。返回值转换为 ，并插入到生成的 ：${}``String``String fun main() &amp;#123; val condition = true println( \"$&amp;#123;if (condition) 'a' else 'b'&amp;#125;\") // [1] val x = 11 println(\"$x + 4 = $&amp;#123;x + 4&amp;#125;\") &amp;#125; /* Output: a 11 + 4 = 15 */ 1.6 数字类型 数字的基本数学运算符是大多数编程语言中可用的运算符：加法（）、减法（）、除法（）、乘法（）和模量（），它们从整数除法生成剩余数：+``-``/``*``% fun main() &amp;#123; val numerator: Int = 19 val denominator: Int = 10 println(numerator % denominator) &amp;#125; /* Output: 9 */ 计算身体质量指数（BMI），即重量（以公斤为单位）除以高度的平方（米）。如果你的体重指数低于 ，你体重不足。和 之间是正常的权重。体重指数越高，体重超标 fun bmiMetric( weight: Double, height: Double ): String &amp;#123; val bmi = weight / (height * height) // [1] return if (bmi &lt; 18.5) \"体重不足\" else if (bmi &lt; 25) \"体重正常\" else \"体重超重\" &amp;#125; fun main() &amp;#123; val weight = 72.57 // 160 lbs val height = 1.727 // 68 inches val status = bmiMetric(weight, height) println(status) &amp;#125; 1.6 boolean &amp;&amp;（和）： 仅在运算符左侧的表达式和右侧的表达式都是 时生成 。true``Boolean``true ||（或）： 如果运算符的左侧或右侧的表达式为 ，或者两者都是 ，则生成 。true``true``true 1.7 while最基本的重复形式使用关键字。只要控制布尔表达式为 ： while``true while (Boolean-expression) &amp;#123; // Code to be repeated &amp;#125; 还有一种方法使用 ，与 关键字一起使用：while``do do &amp;#123; // Code to be repeated &amp;#125; while (Boolean-expression) 1.8 循环和范围值集可以是整数的范围,关键字指示您正在单步执行值：String``in for(v in values) &amp;#123; /* ... */ &amp;#125; fun main() &amp;#123; for (i in 1..3) &amp;#123; println(\"Hey $i!\") &amp;#125; &amp;#125; /* Output: Hey 1! Hey 2! Hey 3! */ 1.9 关键字in关键字测试值是否在一个范围内。in un main() &amp;#123; val percent = 35 println(percent in 1..100) &amp;#125; /* Output: true */ 问题： 三引号字符串不仅对多行字符串有用，而且对于创建正则表达式模式也很有用，因为您不需要用反斜杠转义反斜杠。 以下模式匹配的日期格式为13.06.1992(两个数字，一个点，两个数字，一个点，四个数字): fun getPattern() = “””\\d{2}.\\d{2}.\\d{4}””” 使用month变量重写此模式，使其匹配1992年6月13日格式的日期(两个数字、一个空格、一个月的缩写、一个空格、四个数字)。 代码val month = \"(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\" fun getPattern(): String = \"\"\"\\d&amp;#123;2&amp;#125; $month \\d&amp;#123;4&amp;#125;\"\"\" 1.10 可空类型?问题 学习零安全和安全调用的Kotlin和重写以下Java代码，使它只有一个if表达式: java写法public void sendMessageToClient( @Nullable Client client, @Nullable String message, @NotNull Mailer mailer ) &amp;#123; if (client == null || message == null) return; PersonalInfo personalInfo = client.getPersonalInfo(); if (personalInfo == null) return; String email = personalInfo.getEmail(); if (email == null) return; mailer.sendMessage(email, message); &amp;#125; Kotlin写法fun sendMessageToClient( client: Client?, message: String?, mailer: Mailer ) &amp;#123; val email=client?.personalInfo?.email if (email!=null&amp;&amp;message!=null) mailer.sendMessage(email,message) &amp;#125; 1.11 类对象(class)对象使用属性(val 和 var)存储数据，并使用函数对此数据执行操作。 类: 为本质上是新数据类型的东西定义属性和函数。类也称为用户定义类型。 成员: 类的属性或函数。 成员函数: 仅用于特定对象类的函数。 创建对象: 创建类的 val 或 var。也称为创建该类的实例。 fun main() &amp;#123; val r1 = IntRange(0, 10) val r2 = IntRange(5, 7) println(r1) println(r2) &amp;#125; /* Output: 0..10 5..7 */ 面向对象(class)1.11.1 函数可见性 修饰符 kotlin java private 当前类内部可见 当前类内部可见 public (默认值)，所有类可见 所有类可见 protected 只对当前类,子类可见 只对当前类,子类可见，同一包下可见 internal 对同一模块的类可见 无 1.11.2 创建类面向对象便需要创建类对象，类就是对事物的一种封装，类名通常是名词，类中可以拥有自己的字段和函数，字段是名称，函数是行为动词，面向对象还有继承，多态，等 创建类 class Person&amp;#125;&amp;#123;&amp;#125; 加入字段及函数 class Person&amp;#123; var name=\"\" var age=0 fun eat()&amp;#123; println(name+age) &amp;#125; &amp;#125; 类实例化 val p=person() 类实例化操作 fun man&amp;#123; val p=person() p.name=\"kotlin\" p.age=19 p.eat() &amp;#125; （1）继承 kotlin默认所有非抽象类都是不可以被继承的，想要被继承需要 open 关键字 open class Person&amp;#123; ... &amp;#125; Kotlin继承用 ：替代extends，（）表示构造函数 class Student:Person()&amp;#123; var name=\"\" var grade=0 &amp;#125; （2）接口（interface）基本和java一样 interface 接口是”独立和往往不相关的系统相遇和操作或相互通信的地方。因此，接口是系统不同部分之间的通信手段。 interface Study&amp;#123; fun readBooks() //默认自动实现逻辑 fun doHomeworks()&amp;#123; println(\"do homework default implementation.\") &amp;#125; &amp;#125; （3）构造函数构造函数是创建新对象的特殊函数，默认都会有一个空的构造函数 class Student(val sno:String,val grade:Int):Person()&amp;#123; &amp;#125; val student=Student(\"a123\",5) 主构造函数init&amp;#123; &amp;#125; 次构造函数当没有主构造函数时，this 改为 super constructor(name:String,age:Int):this(\"\",0,name,age)&amp;#123;&amp;#125; constructor():this(\"\",0)&amp;#123;&amp;#125; 特定的classData class 数据类object 单例类java写法 public class Singleton&amp;#123; //禁用外部创建实例 private static Singleton()&amp;#123;&amp;#125;; //单例模式 private static Singleton instance; public synchronized static Singleton getInstance()&amp;#123; if(instance==null)&amp;#123; instance=new Singleton(); &amp;#125; return instance; &amp;#125; //测试方法 public void singletonTest()&amp;#123; System.out.println(\"singletonTest is called.\") &amp;#125; &amp;#125; main&amp;#123; Singleton singleton=Singleton.getInstance(); singleton.singletonTest(); &amp;#125; kotlin写法 object Singleton&amp;#123; fun singletonTest()&amp;#123; println(\"singletonTest is called.\") &amp;#125; &amp;#125; main&amp;#123; Singleton.singletonTest(); &amp;#125; sealed类 密封类（只有同一文件内才可使用）嵌套类 内部类 匿名类类可以嵌套在其他类中： class Outer &amp;#123; private val bar: Int = 1 class Nested &amp;#123; fun foo() = 2 &amp;#125; &amp;#125; val demo = Outer.Nested().foo() // == 2 内部类标记为内部的嵌套类可以访问其外部类的成员。内部类包含对外部类对象的引用： class Outer { private val bar: Int = 1 inner class Inner { fun foo() = bar } } val demo = Outer().Inner().foo() // == 1 匿名内部类使用对象表达式创建匿名内部类实例： window.addMouseListener(object : MouseAdapter() &amp;#123; override fun mouseClicked(e: MouseEvent) &amp;#123; ... &amp;#125; override fun mouseEntered(e: MouseEvent) &amp;#123; ... &amp;#125; &amp;#125;) 1.12 Lambda 编程核心思想（简化编程）,集合的函数式API是学习Lambda编程的绝佳示例 接口 List 实现类 ArraList ​ Set HasSet ​ Map HasMap 集合创建与遍历 集合函数式API Java document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/kotlin-xue-xi/ru-men-ji-chu-xue-xi/"},{"title":"入门简介","text":"[Toc] 官方网站：https://kotlinlang.org/https://kotlinlang.org/ 标语：*一种让开发人员****更快乐的现代编程语言。***永远开源github Kotlin的由来，就是因为java语言的缺点null 空指针，在学习android时经常发生空指针异常的情况，这是编译器无法在编写代码时给出提示，而Kotlin解决了这一问题。 我之前一直以为kotlin是Android团队开发的，不过现在才知道JetBrains公司才是大佬！ 编程语言大致分为编译语言和解释型语言 编译语言：将编写的源代码一次性编译成二进制文件，然后由系统直接执行，如C语言 解释性语言：需要一个解释器，在程序执行时解释器会一行行的读取我们的源代码，然后实时地将其解释为二进制数据再执行，如JAVAY 官方推荐的 学习方式：使用idea 的插件 Edu Tools，不过里边都是英文的教程，可以用翻译插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/kotlin-xue-xi/ru-men-jian-jie/"},{"title":"mysql安装","text":"Centos7安装mysql8.0官方安装教程地址 CentOS 7 安装 MySQL 首先检查 MySQL 是否已安装 yum list installed | grep mysql 如果有的话 就全部卸载 yum -y remove +数据库名称 MySQL 依赖 libaio，所以先要安装 libaio yum search libaio # 检索相关信息 yum install libaio # 安装依赖包 &nbsp; 下载 MySQL Yum Repository 地址为&nbsp;http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm &nbsp; wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 然后 添加 MySQL Yum Repository 添加 MySQL Yum Repository 到你的系统 repository 列表中，执行 &nbsp; yum&nbsp;localinstall&nbsp;mysql-community-release-el7-5.noarch.rpm 如果提示-bash: wget: 未找到命令，请先执行&nbsp;yum install wget&nbsp;安装 wget &nbsp; 验证下是否添加成功 yum repolist enabled | grep \"mysql.*-community.*\" 选择要启用 MySQL 版本 查看 MySQL 版本，执行 yum repolist all | grep mysql 可以看到 5.5， 5.7 版本是默认禁用的，因为现在最新的稳定版是 5.6 yum repolist enabled | grep mysql 查看当前的启动的 MySQL 版本 通过 Yum 来安装 MySQL 执行 yum install mysql-community-server Yum 会自动处理 MySQL 与其他组件的依赖关系： &nbsp; 遇到上述提示，输入 y 继续，执行完成会提示“完毕！”。此时MySQL 安装完成，它包含了 mysql-community-server、mysql-community-client、mysql-community-common、mysql-community-libs 四个包。 执行 rpm -qi mysql-community-server.x86_64 0:5.6.24-3.el7 执行 whereis mysql 可以看到 MySQL 的安装目录是 /usr/bin/ &nbsp; &nbsp; 启动和关闭 MySQL Server 启动 MySQL Server systemctl start mysqld 查看 MySQL Server 状态 systemctl status mysqld 关闭 MySQL Server systemctl stop mysqld 测试是否安装成功 mysql 可以进入 mysql 命令行界面 &nbsp; 防火墙设置 远程访问 MySQL， 需开放默认端口号 3306. 执行 firewall-cmd --permanent --zone=public --add-port=3306/tcpfirewall-cmd --permanent --zone=public --add-port=3306/udp 这样就开放了相应的端口。 执行 firewall-cmd --reload MySQL 安全设置 服务器启动后，可以执行 mysql_secure_installation; 此时输入 root 原始密码（初始化安装的话为空），接下来，为了安全，MySQL 会提示你重置 root 密码，移除其他用户账号，禁用 root 远程登录，移除 test 数据库，重新加载 privilege 表格等，你只需输入 y 继续执行即可。 至此，整个 MySQL 安装完成。 下面可以看到都只能本机访问mysql，如果要外部可以访问mysql，那么host这里应该是显示%，所以这里我们可以选择重新创建一个用户并授予最高的权限，语句如下： grant all privileges on *.* to 'root'@'%' &nbsp;identified by 'lam7' with grant option; &nbsp;//这句话就是给root账户设置密码为lam7且host为%，即外部任何主机均可访问。*.*这个本意是数据库名.表名，我们这里没有写任何表名也没有写数据库名，就是意思所有的数据库都可以用这个root账户访问 flush privileges;//让刚刚修改的权限生效 然后接下来就是重启mysql服务，再次进入到mysql，用查询语句查看user表，如下所示： 如果需要使用外部工具链接mysql 则需要关闭防火墙 systemctl stop firewalld 然后查看状态 systemctl status firewalld 参考 CentOS 7 安装 MySQL &nbsp; 转载于:https://www.cnblogs.com/Lam7/p/6253564.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/mysql-an-zhuang/"},{"title":"Nginx简介","text":"官方安装教程（网速会很慢） 官方入门指南 Nginx简介Nginx是什么？能干什么？有什么特点？ 轻量级web服务器，也是一款反向代理服务器 可直接支持Rails和PHP的程序 可作为http反向代理服务器 负债均衡服务器 邮件代理服务器 帮助前端动静分离Nginx命令 启动systemctl start nginx 停止systemctl stop nginx 状态systemctl status nginx 重启systemctl reload nginxnginx文件目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/nginx-jian-jie/"},{"title":"Readis安装及配置","text":"Readis安装官方网址 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/linux-ru-men/readis-an-zhuang-ji-pei-zhi/"},{"title":"从安装到卸载","text":"根据搜集的资料安装测试并在安装测试过程中整理的文档，部分参考文档在相应位置有标记。如有不足希望不吝赐教。 目录 一、配置yum源 1.下载mysql源安装包 2.安装mysql源 3.检查是否安装成功 4.修改安装版本（非必须） 二、安装mysql 三、启动mysql服务 1.启动 2.查看启动状态 3.设置开机启动 四、配置及部分命令 1.修改登录密码 2.添加远程登录用户 3.sqlyog链接时出现2058异常 4.修改默认编码方式 5.部分参数配置查询命令 五、彻底卸载mysql 1.卸载软件 2.删除文件 一、配置yum源 1.下载mysql源安装包 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/ 复制下载链接：https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm 本次下载目录为：/home/目录，因此进入：cd /home 执行下载命令： wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm &nbsp; 2.安装mysql源 下载完成后使用下面命令安装源： yum localinstall mysql80-community-release-el7-1.noarch.rpm &nbsp; 3.检查是否安装成功 yum repolist enabled | grep \"mysql.*-community.*\" &nbsp; 4.修改安装版本（非必须） 如果需要安装指定版本的mysql，可以修改/etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。 例如要安装5.7版本，将5.7源的enabled=0改成enabled=1，将8.0的enabled=1改成enabled=0即可，如下（本次未做修改，直接安装最新版8.0.12）： &nbsp; 二、安装mysql 直接使用命令：yum install mysql-community-server即可。 &nbsp; 三、启动mysql服务 1.启动 systemctl start mysqld或者service mysqld start &nbsp; 2.查看启动状态 systemctl status mysqld或者service mysqld status &nbsp; 3.设置开机启动 systemctl enable mysqldsystemctl daemon-reload &nbsp; 四、配置及部分命令 1.修改登录密码 mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改： grep 'temporary password' /var/log/mysqld.log 本地MySQL客户端登录 mysql -uroot -p 密码是上一步查询出来的。输入后回车。 然后修改密码： ALTER USER 'root'@'localhost' IDENTIFIED BY 'TestBicon@123'; 或者 set password for 'root'@'localhost'=password('TestBicon@123'); 注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，如下图所示： 通过msyql环境变量可以查看密码策略的相关信息（执行这一步需要先修改默认密码，即执行完上一步修改才可以，否则会报错：ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.）： show variables like '%password%'; validate_password_policy：密码策略，默认为MEDIUM策略 validate_password_dictionary_file：密码策略文件，策略为STRONG才需要 validate_password_length：密码最少长度 validate_password_mixed_case_count：大小写字符长度，至少1个 validate_password_number_count ：数字至少1个 validate_password_special_char_count：特殊字符至少1个 上述参数是默认策略MEDIUM的密码检查规则。 修改密码策略： 在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略： 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件。 validate_password_policy=0 &nbsp; 如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可： validate_password = off &nbsp; 重新启动mysql服务使配置生效：systemctl restart mysqld &nbsp; 2.添加远程登录用户 默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户。 修改root用户远程访问权限： 选择 mysql 数据库：use mysql; 在 mysql 数据库的 user 表中查看当前 root 用户的相关信息： select host, user from user; 查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。 授权 root 用户的所有权限并设置远程访问 GRANT ALL ON *.* TO 'root'@'%'; 如果报错：ERROR 1410 (42000): You are not allowed to create a user with GRANT 则使用： update user set host='%' where user ='root'; 然后使用下面命令使修改生效： flush privileges; 如有需要再执行之前授权报错的命令即可成功，最后同样使用flush privileges;命令刷新。 &nbsp; 3.sqlyog链接时出现2058异常 完成上面的配置使用sqlyog链接时会出现2058的异常，此时我们需要修改mysql，命令行登录mysql（与修改密码中登录相同，使用修改后的密码），然后执行下面的命令： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; 其中password为自己修改的密码。然后SQLyog中重新连接，则可连接成功，OK。 如果报错：ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'则使用下面命令： ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password'; &nbsp; 4.修改默认编码方式 mysql8.0默认编码方式为utf8mb4，因此使用时不需要修改，可使用如下命令查看： SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%'; &nbsp; 如果需要修改其他编码方式，方法有很多，以下仅为举例。 比如需要修改为utf8mb4，可以使用如下方式： 修改mysql配置文件my.cnf（windows为my.ini） my.cnf一般在etc/mysql/my.cnf位置。找到后请在以下三部分里添加如下内容： [client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect='SET NAMES utf8mb4' 重启mysql即可。 collation_connection 、collation_database 、collation_server是什么没关系。但必须保证以下这几个变量必须是utf8mb4。： character_set_client&nbsp; (客户端来源数据使用的字符集) character_set_connection&nbsp;&nbsp;&nbsp;&nbsp; (连接层字符集) character_set_database&nbsp;&nbsp; (当前选中数据库的默认字符集) character_set_results (查询结果字符集) character_set_server (默认的内部操作字符集) &nbsp; 数据库连接参数中: characterEncoding=utf8会被自动识别为utf8mb4，也可以不加这个参数，会自动检测。 而autoReconnect=true是必须加上的。 &nbsp; 5.部分参数配置查询命令 #查询mysql最大连接数设置 show global variables like 'max_conn%'; SELECT @@MAX_CONNECTIONS AS 'Max Connections'; &nbsp; # 查看最大链接数 show global status like 'Max_used_connections'; &nbsp; # 查看慢查询日志是否开启以及日志位置 show variables like 'slow_query%'; &nbsp; # 查看慢查询日志超时记录时间 show variables like 'long_query_time'; &nbsp; # 查看链接创建以及现在正在链接数 show status like 'Threads%'; &nbsp; # 查看数据库当前链接 show processlist; &nbsp; # 查看数据库配置 show variables like '%quer%'; &nbsp; 五、彻底卸载mysql 1.卸载软件 yum remove mysql-community-server 完成后使用rpm -qa|grep mysql命令查看，如果有查询结果，则使用yum remove 名称清理掉。如图： &nbsp; 再使用命令rpm -qa | grep -i mysql查看，如果有结果使用rpm -e 名称卸载。例如： &nbsp; 2.删除文件 rm -rf /var/lib/mysqlrm /etc/my.cnfrm -rf /usr/share/mysql-8.0 如果需要重新安装，在安装完成启动之前可以先对mysql目录赋予权限防止异常发生： chmod -R 777 /var/lib/mysql END document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/mysql8.0/cong-an-zhuang-dao-xie-zai/"},{"title":"初始化密码","text":"一、问题描述 1、在安装MySQL8.0时，修改临时密码，因密码过于简单（如：123456），不符合MySQL密码规范，会触发一个报错信息： ERROR 1819 (HY000): Your password does not satisfy the current policy requirements。 二、遇到问题 1、解决办法调整MySQL密码验证规则，修改 policy 和 length 的值。 2、MySQL 5.7 进行如下设置，即可解决问题：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;3、MySQL 8.0 执行代码：&nbsp;&nbsp;&nbsp;&nbsp; mysql&gt; set global validate_password_policy=0;ERROR 1193 (HY000): Unknown system variable 'validate_password_policy' mysql&gt; set global validate_password_length=1;ERROR 1193 (HY000): Unknown system variable 'validate_password_length'&nbsp; 三、问题解决 1、分析： 可以看到，修改 policy 和 length 的值，在MySQL5.7中好使，在MySQL8.0中无效。'validate_password_policy' 变量不存在。 2、解决： 先修改一个满足的密码 （如：Root_12root） 3、密码修改后，可用命令查看 validate_password 密码验证插件是否安装。 mysql&gt; SHOW VARIABLES LIKE 'validate_password%'; &nbsp; 4、MySQL 8.0 调整密码验证规则： mysql&gt; set global validate_password.policy=0; mysql&gt; set global validate_password.length=1; &nbsp; 5、重新设置密码：&nbsp;ALTER USER 'root'@'localhost' IDENTIFIED BY '你的密码'; &nbsp; 四、问题总结 1、 通过查看 MySQL5.7 和 MySQL8.0 密码验证插件对比，可知两个版本中，变量名不一样。（*_password_policy 和 *_password.policy ） --- 问题原因所在。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/mysql8.0/chu-shi-hua-mi-ma/"},{"title":"1-2-Redis启动","text":"[TOC] Redis启动配置修改redis.conf 配置文件# linux 命令 vi redis.conf /dae 找到目标字符 i:修改 wq:保存退出 daemonize yes ：表示以守护进程的方式启动，后台启动 开启远程连接开放端口6379firewall-cmd --zone=public --list-ports #查看防火墙开放的端口 firewall-cmd --zone=public --add-port=6379/tcp --permanent # 开放6379端口 firewall-cmd --reload # 配置立即生效 firewall-cmd --zone=public --list-ports Redis默认不支持远程连接，需要手动开启 修改redis.conf文件 注释bind 127.0.0.1 开启密码校验 requirepass kujin 保存退出，重启redis redis-server redis.conf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/1-2-redis-qi-dong/"},{"title":"2-1-数据结构","text":"[TOC] 六种基本类型 数据类型 数据类型存储的值 说明 String 字符串 保存字符串.整数, 浮点数 可以对字符串进行操作,增加字符串或求子串,如果时整数或者浮点数,可以计算,比如自增 List 列表 它是一个链表,每一个节点都包含字符串 Redis支持从链表的两端插入 set 集合 它是一个收集器, 但是是无序的,它里面每一个元素都是字符串,而且是独一无二的,各不相同 可以新增,读取,删除删除单个元素,检测一个元素是否在集合中,计算和其他集合的交集,并集,和差集等;随机从集合中读取元素 Hash 哈希散列表 它类似于java语言中map 是一个键值对应的无序列表 可以增删改查单个键值对,也可以获取所有的键值对 Zset 有序集合 可以包含字符串,整数,浮点数,分值(score),元素的排列是依据分值的大小决定的 可以增删改查元素,根据分值的范围或成员来获取键值对 HyperLogLog 基数 计算重复的值,以确定存储的数量 只提供基数的运算,不提供返回的功能 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/2-1-shu-ju-jie-gou/"},{"title":"2-2 数据结构的常用命令","text":"[Toc] 前言Redis清空命令—flushdb 1.字符串数据结构命令2.链表数据结构命令3.哈希数据结构命令4.集合数据结构命令5.有序集合串数据结构命令6.基数的含义和命令 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/2-2-shu-ju-jie-gou-de-chang-yong-ming-ling/"},{"title":"3-1分布式锁","text":"分布式锁场景1. 问题场景 例如一个简单的用户操作， 一个线程去修改用户状态，首先从数据库读出用户状态，然后再内存中修改，修改完成后再存储 在多线程中，由于读取，修改，存储，是三个操作，不是原子操作，可能会线程操作冲突 可以使用分布式锁限制程序的并发操作 原理 分布式锁，通过进入线程占位，当别的线程操作时，发现已经有人占位了，就会放弃或稍后再试 在Redis中，占位一般用setnx 指令，先进来的线程先占位，线程的操作执行完成后，再del指令释放位子 Redis redis = new Redis(); redis.execute(jedis -> &amp;#123; Long setnx = jedis.setnx(\"k1\", \"v1\"); if (setnx==1)&amp;#123; //没人占位 jedis.set(\"name\", \"kujin\"); System.out.println(jedis.get(\"name\")); jedis.del(\"k1\");//删除k1，释放位置 &amp;#125;else &amp;#123; //有人占位,停止 &amp;#125; &amp;#125;); 上述代码存在问题，如果jedis在set get中出现异常导致del 指令没有运行，这样key1无法释放，后面的请求全部阻塞，形成死锁 解决方法，给锁一个过期时间，确保一定时间之后，能够得到释放 Redis redis = new Redis(); redis.execute(jedis -> &amp;#123; Long setnx = jedis.setnx(\"k1\", \"v1\"); if (setnx==1)&amp;#123; jedis.expire(\"k1\",5);//设置5秒的过期时间，防止执行过程中异常导致锁无法释放的问题 //没人占位 jedis.set(\"name\", \"kujin\"); System.out.println(jedis.get(\"name\")); jedis.del(\"k1\");//删除k1，释放位置 &amp;#125;else &amp;#123; //有人占位,停止 &amp;#125; &amp;#125;); 这样改造之后还存在一个问题，就是在获取锁和设置过期时间服务器挂掉了，这个时候形成死锁 为了解决这个问题，Redis2.8开始，setnx和expire可以通过一个命令一起执行 Redis redis = new Redis(); redis.execute(jedis -> &amp;#123; /* Long setnx = jedis.setnx(\"k1\", \"v1\"); jedis.expire(\"k1\",5);//设置5秒的过期时间，防止执行过程中异常导致锁无法释放的问题 */ //两个指令合成一个 String set = jedis.set(\"k1\", \"v1\", new SetParams().ex(5)); if (\"OK\".equalsIgnoreCase(set))&amp;#123; //没人占位 jedis.set(\"name\", \"kujin\"); System.out.println(jedis.get(\"name\")); jedis.del(\"k1\");//删除k1，释放位置 &amp;#125;else &amp;#123; //有人占位,停止 &amp;#125; &amp;#125;); 2.解决超时时间 为了防止业务代码，在执行的过程中抛出异常，我们给每一个锁添加一个超时时间，超时过后自动释放， 新的问题，如果执行业务非常耗时，可能会导致紊乱 举个栗子 第一个线程获取到锁，开始执行业务，业务执行8秒，这样会在第一个线程的任务还未执行成功，锁5秒以过期， 导致第二个线程会获取到锁执行，在第二了线程执行了3秒，第一个线程执行完成释放资源，第三个线程进来 对于这个问题解决方式 避免执行耗时操作 将锁的value设置为一个随机字符串，每次释放时检查字符串是否一致，一致释放，否则 不释放 第二种方式不具有原子性，为了解决这个问题，引入Lua脚本 [Lua脚本](3-2 Lua脚本.md) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/3-1-fen-bu-shi-suo/"},{"title":"3-2 Lua脚本","text":"Lua脚本 在Redis的2.6以上版本中，可以使用Lua语言操作Redis Redis语言具有原子性，操作过程不会中断，有助于Redis对并发操作数据的一致性 1.Redis支持两种方法运行脚本 直接输入Lua语言程序代码 将Lua语言编写成文件 Redis支持缓存脚本，它会使用SHA-1算法对脚本进行签名，然后通过把SHA-1标识返回回来，通过标识运行 命令格式 eval Lua-script key-num [key1 key2 ...][value1 value2 ...] eval 代表Lua语言命令 Lua-script 代表Lua语言脚本 key-num 代表有多少的key ，Redis中的key是从1开始的，如果key没有参数 那么写0 [key1 key2 …]作为参数传递给Lua语言 需要和key-num对应起来 [value1 value2 …]参数传递给Lua语言 2.举个栗子这个脚本只是返回一个字符串，不需要任何参数 eval \"return 'hello Lua'\" 0 设置一个键值对，可以在Lua语言中采用redis.call(command,key[parm1,parm2 …]) command是命令 set get del 等 Key是被操作的键 parm1，parm2 代表key的参数 eval \"redis.call('set',KEYS[1],ARGV[1])\" 1 lua-key lua-value 脚本中的KEY[1]代表读取传递给Lua脚本的第一个key参数， 而ARGV[1]代表第一个非key参数。 3.使用加密算法有时候需要多次执行同样一段代码脚本，这时候可以使用Redis缓存脚本的功能，在Redis中脚本会通过SHA-1签名算法加密脚本，然后返回一个标识字符串 通过这个字符串执行加密脚本，好处是如果脚本很长，客户端传输需要很长时间，使用标识符，则需要传递32位字符即可，从而提高传输效率，提高性能 script load script evalsha shastring keynum [key1 key2 ..] [parm1 parm2 ...] 1.举个栗子script load \"redis.call('set',KEYS[1],ARGV[1])\" evalsha 7cfb4342127e7ab3d63ac05e0d3615fd50b45b06 1 sha-key val get sha-key 4.java代码使用Lua脚本 //执行简单的脚本 String helloJava = (String) jedis.eval(\"return 'hello java'\"); System.out.println(helloJava); //执行带参数的脚本 jedis.eval(\"redis.call('set',KEYS[1],ARGV[1])\",1,\"lua-key\",\"lua-value\"); String luaKey = jedis.get(\"lua-key\"); System.out.println(luaKey); //缓存脚本，返回sha1签名标识 String sha1 = jedis.scriptLoad(\"redis.call('set',KEYS[1],ARGV[1])\"); //通过标识执行脚本 jedis.evalsha(sha1,1,new String[]&amp;#123;\"sha-key\",\"sha-val\"&amp;#125;); //获取执行脚本后的数据 String shaVal = jedis.get(\"sha-key\"); System.out.println(shaVal); 5.使用RedisScript接口对象通过Lua脚本操作对象/** * 使用RedisScript接口对象通过Lua脚本操作对象 */ @Test public void redisScript_Lua()&amp;#123; //1.定义默认脚本封装类 DefaultRedisScript&lt;Role> redisScript = new DefaultRedisScript&lt;>(); //2. 设置脚本 redisScript.setScriptText(\"redis.call('set',KEYS[1],ARGV[1]) return redis.call('get',KEYS[1])\"); //3. 定义操作key的列表 ArrayList&lt;String> keyList = new ArrayList&lt;>(); keyList.add(\"role1\"); //4. 需要序列化保存和读取的对象 Role role = new Role(); role.setId(1L); role.setRoleName(\"role_name_1\"); role.setNote(\"note_1\"); //5. 获取标识字符串 String sha1 = redisScript.getSha1(); System.out.println(sha1); //6. 设置返回结果类型，如果没有这句话，返回结果为空 redisScript.setResultType(Role.class); //7. 定义序列化器 JdkSerializationRedisSerializer serializer = new JdkSerializationRedisSerializer(); //8. 执行脚本 RedisTemplate jedisTemlate = Utils.getJedisTemlate(); //第一个是redisScript接口对象，第二个是参数序列化器 //第三个是结果序列化器，第四个是Redis的key列表，最后是参数列表 Role obj = (Role) jedisTemlate.execute(redisScript, serializer, serializer, keyList, role); System.out.println(obj.toString()); &amp;#125; 6.执行Lua文件6.1 在服务端编写Lua文件代码 test.lua if redis.call(\"get\",KEYS[1])==ARGV[1] then return redis.call(\"del\",KEY[1]) else return 0 end 执行如下命令 cat lua/test.lua | redis-cli -a kujin script load --pipe script load 这个命令会在redis服务器缓存lua脚本，并返回脚本内容的SHA1校验和 java端调用时，传入CHA1校验和作为参数，redis服务端会知道调用哪个lua脚本 /** * 执行Lua文件 */ @Test public void excuLuaFile()&amp;#123; Redis redis = new Redis(); for (int i = 0; i &lt; 2; i++) &amp;#123; redis.execute(jedis -> &amp;#123; //1.获取一个随机字符串 String value = UUID.randomUUID().toString(); //2. 获取锁 String k1 = jedis.set(\"k1\", value, new SetParams().nx().ex(5)); //3. 判断是否成功拿到锁 if (k1!=null&amp;&amp;\"ok\".equalsIgnoreCase(k1))&amp;#123; //4具体的业务操作 jedis.set(\"site\",\"www.baidu.com\"); System.out.println(jedis.get(\"site\")); //5 释放锁 jedis.evalsha(\"b8059ba43af6ffe8bed3db65bac35d452f8115d8\", Collections.singletonList(\"k1\"), Collections.singletonList(value)); &amp;#125;else &amp;#123; System.out.println(\"没拿到锁\"); &amp;#125; &amp;#125;); &amp;#125; &amp;#125; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/3-2-lua-jiao-ben/"},{"title":"3-3 消息队列","text":"[Toc] 简介平时说的消息队列，一般是指RbbitMQ, RocketMQ,ActiveMQ 以及大数据里边的Kafka，这些都是一些比较专业的消息中间件 Redis中也有自己的消息队列 1.消息队列Redis中做消息队列，使用他里边的List数据结构可以实现，我们可以 lpush/rpush 操作来实现入队 lpop/rpop 实现出列 详细操作 java端在客户端（java端）我们会维护一个死循环不停地从队列中读取数据，并处理，如果队列中有消息，则直接获取，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成大量资源浪费，使用blpop/brpopo 2.延迟消息队列 延迟队列可以通过zset来实现，因为zset中有一个score，我们可以把时间作为score，将value存到redis中，然后通过循环的方式不断地通过轮询的方式，去不断的读取出来 如果消息是一个字符串，直接发送即可，如果是一个对象，则需要进行对象序列化，这里我们使用JSON来实现序列化与反序列化 首先在项目中吗，添加Json依赖 &lt;dependency> &lt;groupId>com.fasterxml.jackson.core&lt;/groupId> &lt;artifactId>jackson-databind&lt;/artifactId> &lt;version>2.10.3&lt;/version> &lt;/dependency> /** * 类：消息实体 * 编写人：kujin * 创建时间：2020/7/28 * 修改时间：2020/7/28 */ public class Message &amp;#123; private String id; private Object data; @Override public String toString() &amp;#123; return \"Message&amp;#123;\" + \"id='\" + id + '\\'' + \", data=\" + data + '&amp;#125;'; &amp;#125; public String getId() &amp;#123; return id; &amp;#125; public void setId(String id) &amp;#123; this.id = id; &amp;#125; public Object getData() &amp;#123; return data; &amp;#125; public void setData(Object data) &amp;#123; this.data = data; &amp;#125; &amp;#125; package com.kujin.springredistest.redis.redis_queue; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import redis.clients.jedis.Jedis; import javax.xml.crypto.Data; import java.util.Date; import java.util.Set; import java.util.UUID; /** * 类：延迟消息队列 * 编写人：kujin * 创建时间：2020/7/28 * 修改时间：2020/7/28 */ public class DelayMsgQueue &amp;#123; private Jedis jedis; private String queue; public DelayMsgQueue(Jedis jedis, String queue) &amp;#123; this.jedis = jedis; this.queue = queue; &amp;#125; /** * 消息入列 * @param data 要发送的消息 */ public void queue(Object data)&amp;#123; //构造一个消息 Message message = new Message(); message.setId(UUID.randomUUID().toString()); message.setData(data); //序列化 try &amp;#123; String json = new ObjectMapper().writeValueAsString(message); //消息发送,延迟5秒 System.out.println(\"msg publish: \"+new Date()); jedis.zadd(queue,System.currentTimeMillis()+50000,json); &amp;#125; catch (JsonProcessingException e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; /** * 消息发送 */ public void loop()&amp;#123; while (!Thread.interrupted())&amp;#123; //读取score 到当前时间戳的消息 Set&lt;String> zrange = jedis.zrangeByScore(queue, 0, System.currentTimeMillis(), 0, 1); //如果消息为空,则休息500毫秒 if (zrange.isEmpty())&amp;#123; try &amp;#123; Thread.sleep(500); &amp;#125; catch (InterruptedException e) &amp;#123; e.printStackTrace(); break; &amp;#125; continue; &amp;#125; //如果读取到消息,则将消息读取出来 String next = zrange.iterator().next(); if (jedis.zrem(queue,next)>0)&amp;#123; //消息取到,处理业务 try &amp;#123; Message message = new ObjectMapper().readValue(next, Message.class); System.out.println(\"receive msg: \"+message); &amp;#125; catch (JsonProcessingException e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; &amp;#125; &amp;#125; &amp;#125; package com.kujin.springredistest.redis.redis_queue; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import redis.clients.jedis.Jedis; import javax.xml.crypto.Data; import java.util.Date; import java.util.Set; import java.util.UUID; /** * 类：延迟消息队列 * 编写人：kujin * 创建时间：2020/7/28 * 修改时间：2020/7/28 */ public class DelayMsgQueue &amp;#123; private Jedis jedis; private String queue; public DelayMsgQueue(Jedis jedis, String queue) &amp;#123; this.jedis = jedis; this.queue = queue; &amp;#125; /** * 消息入列 * @param data 要发送的消息 */ public void queue(Object data)&amp;#123; //构造一个消息 Message message = new Message(); message.setId(UUID.randomUUID().toString()); message.setData(data); //序列化 try &amp;#123; String json = new ObjectMapper().writeValueAsString(message); //消息发送,延迟5秒 System.out.println(\"msg publish: \"+new Date()); jedis.zadd(queue,System.currentTimeMillis()+5000,json); &amp;#125; catch (JsonProcessingException e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; /** * 消息发送 */ public void loop()&amp;#123; while (!Thread.interrupted())&amp;#123; //读取score 到当前时间戳的消息 Set&lt;String> zrange = jedis.zrangeByScore(queue, 0, System.currentTimeMillis(), 0, 1); //如果消息为空,则休息500毫秒 if (zrange.isEmpty())&amp;#123; try &amp;#123; Thread.sleep(500); &amp;#125; catch (InterruptedException e) &amp;#123; e.printStackTrace(); break; &amp;#125; continue; &amp;#125; //如果读取到消息,则将消息读取出来 String next = zrange.iterator().next(); if (jedis.zrem(queue,next)>0)&amp;#123; //消息取到,处理业务 try &amp;#123; Message message = new ObjectMapper().readValue(next, Message.class); System.out.println(\"receive msg: \"+new Date()+\">>>>>\"+message); &amp;#125; catch (JsonProcessingException e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; &amp;#125; &amp;#125; &amp;#125; github document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/3-3-xiao-xi-dui-lie/"},{"title":"Java客户端","text":"[TOC] 开启远程连接开放端口6379firewall-cmd --zone=public --list-ports #查看防火墙开放的端口 firewall-cmd --zone=public --add-port=6379/tcp --permanent # 开放6379端口 firewall-cmd --reload # 配置立即生效 firewall-cmd --zone=public --list-ports Redis默认不支持远程连接，需要手动开启 修改redis.conf文件 注释bind 127.0.0.1 开启密码校验 requirepass kujin 保存退出，重启redis redis-server redis.conf Jedismaven仓库：https://mvnrepository.com/artifact/redis.clients/jedis 1. 添加依赖compile group: 'redis.clients', name: 'jedis', version: '3.3.0' 2. java代码测试package com.kujin.springredis; import redis.clients.jedis.Jedis; /** * 类：在java中使用Redis * 编写人：kujin * 创建时间：2020/7/23 * 修改时间：2020/7/23 */ public class Java_Redis_Text &amp;#123; public static void main(String[] args) &amp;#123; Jedis jedis=new Jedis(\"192.168.2.168\",6379);//连接redis jedis.auth(\"kujin\");//输入密码 int i=0;//记录操作次数 try &amp;#123; long start = System.currentTimeMillis();//开始时间 while (true)&amp;#123; long end = System.currentTimeMillis();//结束时间 if (end-start>=1000)&amp;#123;//时间大于1秒，退出 break; &amp;#125; i++; jedis.set(\"test\"+i,i+\"\"); &amp;#125; &amp;#125;finally &amp;#123;//关闭连接 jedis.close(); &amp;#125; System.out.println(\"redis每秒操作 \"+ i+ \"次\"); &amp;#125; &amp;#125; 3. 连接池1. 定义接口约束public interface CllWithJedis &amp;#123; void call(Jedis jedis); &amp;#125; 2. 规范redis连接创建public class Redis &amp;#123; //定义redis连接池 private JedisPool pool; public Redis() &amp;#123; //配置连接参数 GenericObjectPoolConfig config=new GenericObjectPoolConfig(); config.setMaxIdle(50);//最大空闲数 config.setMaxTotal(100);//最大连接数 config.setTestOnBorrow(true);//在空闲时检查有效性 //配置参数，地址，端口，超时时间，密码 pool=new JedisPool(config,\"192.168.2.168\",6379,20000,\"kujin\"); &amp;#125; public void execute(CllWithJedis cllWithJedis)&amp;#123; //在try里获取单个连接 try (Jedis jedis=pool.getResource())&amp;#123; cllWithJedis.call(jedis); &amp;#125; &amp;#125; &amp;#125; 3. 使用redispublic static void main(String[] args) &amp;#123; Redis redis=new Redis(); redis.execute(jedis1 -> &amp;#123; System.out.println(jedis1.ping()); &amp;#125;); &amp;#125; Lettuce（简单了解）Github官方地址 1. 添加依赖compile group: 'io.lettuce', name: 'lettuce-core', version: '6.0.0.M1' 2. 简单测试案例public class LettuceTest &amp;#123; static RedisClient client = RedisClient.create(\"redis://kujin@192.168.2.168\");//获取redis实例 public static void main(String[] args) &amp;#123; baseUsage();//基本用法 &amp;#125; private static void baseUsage() &amp;#123; StatefulRedisConnection&lt;String, String> connection = client.connect(); RedisStringCommands sync = connection.sync();//同步对象 sync.set(\"ku\",\"jin\");//设置值 String ku = (String) sync.get(\"ku\");//获取值 System.out.println(ku); &amp;#125; &amp;#125; Jedis和Lettuce比较 Jedis在实现过程中是直接连接Redis的，在多个线程之间共享一个Jedis实例，这是线程不安全的，如果在多线程创建下使用需要创建连接池，这样每个jedis都有redis实例 Lettuce基于Netty NIO框架构建，所以克服了jedis中线程不安全的问题，Lettuce支持同步，异步，以及响应调用，多个线程可以共享一个实例 Spring中使用Redis1.添加依赖compile group: 'org.springframework.data', name: 'spring-data-redis', version: '2.3.2.RELEASE' 2.配置文件appcationContext.xml &lt;!-- Spring配置JedisPoolConfig对象--> &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"> &lt;!--最大空闲数 --> &lt;property name=\"maxIdle\" value=\"50\" /> &lt;!--最大连接数 --> &lt;property name=\"maxTotal\" value=\"100\" /> &lt;!--最大等待时间 --> &lt;property name=\"maxWaitMillis\" value=\"20000\" /> &lt;/bean> &lt;!--spring配置JedisConnectionFactory--> &lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"> &lt;property name=\"hostName\" value=\"192.168.2.168\" /> &lt;property name=\"port\" value=\"6379\" /> &lt;property name=\"password\" value=\"kujin\"/> &lt;property name=\"poolConfig\" ref=\"poolConfig\" /> &lt;/bean> &lt;!--Spring配置RedisTemplate--> &lt;bean id=\"jdkSerializationRedisSerializer\" class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\" /> &lt;bean id=\"stringRedisSerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\" /> &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"> &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /> &lt;property name=\"keySerializer\" ref=\"stringRedisSerializer\" /> &lt;property name=\"valueSerializer\" ref=\"jdkSerializationRedisSerializer\" /> &lt;/bean> 3.关键代码pojo public class Role implements Serializable &amp;#123; private static final long serialVersionUID = 6977402643848374753L; private long id; private String roleName; private String note; public long getId() &amp;#123; return id; &amp;#125; public void setId(long id) &amp;#123; this.id = id; &amp;#125; public String getRoleName() &amp;#123; return roleName; &amp;#125; public void setRoleName(String roleName) &amp;#123; this.roleName = roleName; &amp;#125; public String getNote() &amp;#123; return note; &amp;#125; public void setNote(String note) &amp;#123; this.note = note; &amp;#125; &amp;#125; main.java private static void testSpring() &amp;#123; //spring配置 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //获取redis RedisTemplate redisTemplate = applicationContext.getBean(RedisTemplate.class); //角色实体 Role role = new Role(); role.setId(1L); role.setRoleName(\"role_name_1\"); role.setNote(\"note_1\"); //redsi操作 redisTemplate.opsForValue().set(\"role_1\", role); Role role1 = (Role) redisTemplate.opsForValue().get(\"role_1\"); System.out.println(role1.getRoleName()); &amp;#125; 4. 优化SessionCallback接口对redis连接进行了封装，可以把多个命令放入到同一个Redis连接中执行 private static void testSessionCallback() &amp;#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); RedisTemplate redisTemplate = applicationContext.getBean(RedisTemplate.class); Role role = new Role(); role.setId(1); role.setRoleName(\"role_name_1\"); role.setNote(\"role_note_1\"); //SessionCallback接口对redis连接进行了封装，可以把多个命令放入到同一个Redis连接中执行 SessionCallback callBack = new SessionCallback&lt;Role>() &amp;#123; @Override public Role execute(RedisOperations ops) throws DataAccessException &amp;#123; ops.boundValueOps(\"role_1\").set(role); return (Role) ops.boundValueOps(\"role_1\").get(); &amp;#125; &amp;#125;; Role savedRole = (Role) redisTemplate.execute(callBack); System.out.println(savedRole.getId()); &amp;#125; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/java-ke-hu-duan/"},{"title":"简介","text":"Redis（Remote Dictionary Service）是一个NoSql数据库，基于c开发，键值对存储数据，运行在缓存内存中，高速缓存数据 特点： 支持数据持久化 支持多种不同的数据结构 支持从模式的数据备份 自带发布订阅系统 定时器，计数器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/hexo.github.io/2020/08/03/sui-xin-ji/redis-xue-xi/jian-jie/"}],"tags":[{"name":"3-1网络访问","slug":"3-1网络访问","link":"/hexo.github.io/tags/3-1%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE/"},{"name":"3-2-1安装Apache服务器","slug":"3-2-1安装Apache服务器","link":"/hexo.github.io/tags/3-2-1%E5%AE%89%E8%A3%85Apache%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"3-2网络访问-数据格式","slug":"3-2网络访问-数据格式","link":"/hexo.github.io/tags/3-2%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"},{"name":"3-3 封装网络请求","slug":"3-3-封装网络请求","link":"/hexo.github.io/tags/3-3-%E5%B0%81%E8%A3%85%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"name":"3-4 开源网络封装库Retofit","slug":"3-4-开源网络封装库Retofit","link":"/hexo.github.io/tags/3-4-%E5%BC%80%E6%BA%90%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85%E5%BA%93Retofit/"},{"name":"Android Studio使用技巧","slug":"Android-Studio使用技巧","link":"/hexo.github.io/tags/Android-Studio%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"BottomNavigationView控件学习md","slug":"BottomNavigationView控件学习md","link":"/hexo.github.io/tags/BottomNavigationView%E6%8E%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0md/"},{"name":"Jetpack","slug":"Jetpack","link":"/hexo.github.io/tags/Jetpack/"},{"name":"使用 ViewModel 处理配置更改","slug":"使用-ViewModel-处理配置更改","link":"/hexo.github.io/tags/%E4%BD%BF%E7%94%A8-ViewModel-%E5%A4%84%E7%90%86%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%94%B9/"},{"name":"视图导航","slug":"视图导航","link":"/hexo.github.io/tags/%E8%A7%86%E5%9B%BE%E5%AF%BC%E8%88%AA/"},{"name":"基础学习","slug":"基础学习","link":"/hexo.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"1-1 安装bitnami虚拟机","slug":"1-1-安装bitnami虚拟机","link":"/hexo.github.io/tags/1-1-%E5%AE%89%E8%A3%85bitnami%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"1-1-安装","slug":"1-1-安装","link":"/hexo.github.io/tags/1-1-%E5%AE%89%E8%A3%85/"},{"name":"1-1 简介","slug":"1-1-简介","link":"/hexo.github.io/tags/1-1-%E7%AE%80%E4%BB%8B/"},{"name":"1-2 连接SSH","slug":"1-2-连接SSH","link":"/hexo.github.io/tags/1-2-%E8%BF%9E%E6%8E%A5SSH/"},{"name":"1-3 安装桌面","slug":"1-3-安装桌面","link":"/hexo.github.io/tags/1-3-%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2/"},{"name":"2-1文档学习","slug":"2-1文档学习","link":"/hexo.github.io/tags/2-1%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"},{"name":"简介","slug":"简介","link":"/hexo.github.io/tags/%E7%AE%80%E4%BB%8B/"},{"name":"1-2-常用操作","slug":"1-2-常用操作","link":"/hexo.github.io/tags/1-2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"name":"Untitled","slug":"Untitled","link":"/hexo.github.io/tags/Untitled/"},{"name":"1-2 使用教程","slug":"1-2-使用教程","link":"/hexo.github.io/tags/1-2-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"1-1简介","slug":"1-1简介","link":"/hexo.github.io/tags/1-1%E7%AE%80%E4%BB%8B/"},{"name":"1-1 简单使用","slug":"1-1-简单使用","link":"/hexo.github.io/tags/1-1-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"name":"1-1 Git 设置和配置","slug":"1-1-Git-设置和配置","link":"/hexo.github.io/tags/1-1-Git-%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"name":"IDEA中Tomcat日志乱码","slug":"IDEA中Tomcat日志乱码","link":"/hexo.github.io/tags/IDEA%E4%B8%ADTomcat%E6%97%A5%E5%BF%97%E4%B9%B1%E7%A0%81/"},{"name":"2-1 配置主题","slug":"2-1-配置主题","link":"/hexo.github.io/tags/2-1-%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%A2%98/"},{"name":"3-1 hexo与md文件格式的冲突","slug":"3-1-hexo与md文件格式的冲突","link":"/hexo.github.io/tags/3-1-hexo%E4%B8%8Emd%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%86%B2%E7%AA%81/"},{"name":"Filter","slug":"Filter","link":"/hexo.github.io/tags/Filter/"},{"name":"2-1 Git忽略文件","slug":"2-1-Git忽略文件","link":"/hexo.github.io/tags/2-1-Git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/"},{"name":"2-2 Git获取和创建项目","slug":"2-2-Git获取和创建项目","link":"/hexo.github.io/tags/2-2-Git%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"name":"3-1 关键命令","slug":"3-1-关键命令","link":"/hexo.github.io/tags/3-1-%E5%85%B3%E9%94%AE%E5%91%BD%E4%BB%A4/"},{"name":"3-2 添加","slug":"3-2-添加","link":"/hexo.github.io/tags/3-2-%E6%B7%BB%E5%8A%A0/"},{"name":"junit简介","slug":"junit简介","link":"/hexo.github.io/tags/junit%E7%AE%80%E4%BB%8B/"},{"name":"idea工具的使用","slug":"idea工具的使用","link":"/hexo.github.io/tags/idea%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"idea报java版本错误解决方法","slug":"idea报java版本错误解决方法","link":"/hexo.github.io/tags/idea%E6%8A%A5java%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"name":"创建代码块模板","slug":"创建代码块模板","link":"/hexo.github.io/tags/%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A8%A1%E6%9D%BF/"},{"name":"利用IDEA学习编程语言","slug":"利用IDEA学习编程语言","link":"/hexo.github.io/tags/%E5%88%A9%E7%94%A8IDEA%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"利用IDEA明明导入了包却显示缺少保留相关类","slug":"利用IDEA明明导入了包却显示缺少保留相关类","link":"/hexo.github.io/tags/%E5%88%A9%E7%94%A8IDEA%E6%98%8E%E6%98%8E%E5%AF%BC%E5%85%A5%E4%BA%86%E5%8C%85%E5%8D%B4%E6%98%BE%E7%A4%BA%E7%BC%BA%E5%B0%91%E4%BF%9D%E7%95%99%E7%9B%B8%E5%85%B3%E7%B1%BB/"},{"name":"快捷键","slug":"快捷键","link":"/hexo.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"插件使用","slug":"插件使用","link":"/hexo.github.io/tags/%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"1.学习网址","slug":"1-学习网址","link":"/hexo.github.io/tags/1-%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80/"},{"name":"1-2 CentOS镜像使用帮助","slug":"1-2-CentOS镜像使用帮助","link":"/hexo.github.io/tags/1-2-CentOS%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/"},{"name":"Linux","slug":"Linux","link":"/hexo.github.io/tags/Linux/"},{"name":"linux常用命令","slug":"linux常用命令","link":"/hexo.github.io/tags/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"MyBatis框架","slug":"MyBatis框架","link":"/hexo.github.io/tags/MyBatis%E6%A1%86%E6%9E%B6/"},{"name":"Spring入门","slug":"Spring入门","link":"/hexo.github.io/tags/Spring%E5%85%A5%E9%97%A8/"},{"name":"多线程编程","slug":"多线程编程","link":"/hexo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"name":"字节流与字符流","slug":"字节流与字符流","link":"/hexo.github.io/tags/%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81/"},{"name":"index","slug":"index","link":"/hexo.github.io/tags/index/"},{"name":"spring注解","slug":"spring注解","link":"/hexo.github.io/tags/spring%E6%B3%A8%E8%A7%A3/"},{"name":"1-1 入门学习","slug":"1-1-入门学习","link":"/hexo.github.io/tags/1-1-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习记录（一）","slug":"学习记录（一）","link":"/hexo.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"},{"name":"Spring Framework简介","slug":"Spring-Framework简介","link":"/hexo.github.io/tags/Spring-Framework%E7%AE%80%E4%BB%8B/"},{"name":"入门基础学习","slug":"入门基础学习","link":"/hexo.github.io/tags/%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"入门简介","slug":"入门简介","link":"/hexo.github.io/tags/%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"},{"name":"数据类型","slug":"数据类型","link":"/hexo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"框架搭建","slug":"框架搭建","link":"/hexo.github.io/tags/%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"},{"name":"iptables的学习","slug":"iptables的学习","link":"/hexo.github.io/tags/iptables%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"name":"2-1android moudle与libery切换","slug":"2-1android-moudle与libery切换","link":"/hexo.github.io/tags/2-1android-moudle%E4%B8%8Elibery%E5%88%87%E6%8D%A2/"},{"name":"2-1阿里云服务器远程登录密码","slug":"2-1阿里云服务器远程登录密码","link":"/hexo.github.io/tags/2-1%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81/"},{"name":"Centos虚拟机网络连接问题","slug":"Centos虚拟机网络连接问题","link":"/hexo.github.io/tags/Centos%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"},{"name":"Linux准备工作","slug":"Linux准备工作","link":"/hexo.github.io/tags/Linux%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"},{"name":"LINUX设置防火墙","slug":"LINUX设置防火墙","link":"/hexo.github.io/tags/LINUX%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"mysql安装","slug":"mysql安装","link":"/hexo.github.io/tags/mysql%E5%AE%89%E8%A3%85/"},{"name":"Nat连接网络","slug":"Nat连接网络","link":"/hexo.github.io/tags/Nat%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"},{"name":"Nginx简介","slug":"Nginx简介","link":"/hexo.github.io/tags/Nginx%E7%AE%80%E4%BB%8B/"},{"name":"Readis安装及配置","slug":"Readis安装及配置","link":"/hexo.github.io/tags/Readis%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"name":"文件命令操作md","slug":"文件命令操作md","link":"/hexo.github.io/tags/%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9Cmd/"},{"name":"用户操作","slug":"用户操作","link":"/hexo.github.io/tags/%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C/"},{"name":"防火墙的设置","slug":"防火墙的设置","link":"/hexo.github.io/tags/%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E8%AE%BE%E7%BD%AE/"},{"name":"前期准备","slug":"前期准备","link":"/hexo.github.io/tags/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"name":"01 Spring Boot入门","slug":"01-Spring-Boot入门","link":"/hexo.github.io/tags/01-Spring-Boot%E5%85%A5%E9%97%A8/"},{"name":"1-1-安装环境","slug":"1-1-安装环境","link":"/hexo.github.io/tags/1-1-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/"},{"name":"PermissionX权限管理库","slug":"PermissionX权限管理库","link":"/hexo.github.io/tags/PermissionX%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%BA%93/"},{"name":"从安装到卸载","slug":"从安装到卸载","link":"/hexo.github.io/tags/%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%8D%B8%E8%BD%BD/"},{"name":"初始化密码","slug":"初始化密码","link":"/hexo.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%86%E7%A0%81/"},{"name":"1-2-Redis启动","slug":"1-2-Redis启动","link":"/hexo.github.io/tags/1-2-Redis%E5%90%AF%E5%8A%A8/"},{"name":"2-1-数据结构","slug":"2-1-数据结构","link":"/hexo.github.io/tags/2-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"2-2 数据结构的常用命令","slug":"2-2-数据结构的常用命令","link":"/hexo.github.io/tags/2-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"3-1分布式锁","slug":"3-1分布式锁","link":"/hexo.github.io/tags/3-1%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"3-2 Lua脚本","slug":"3-2-Lua脚本","link":"/hexo.github.io/tags/3-2-Lua%E8%84%9A%E6%9C%AC/"},{"name":"3-3 消息队列","slug":"3-3-消息队列","link":"/hexo.github.io/tags/3-3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"Java客户端","slug":"Java客户端","link":"/hexo.github.io/tags/Java%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"错误问题","slug":"错误问题","link":"/hexo.github.io/tags/%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/"},{"name":"问题总结","slug":"问题总结","link":"/hexo.github.io/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"mysql数据库的安装与配置","slug":"mysql数据库的安装与配置","link":"/hexo.github.io/tags/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"name":"vsftpd","slug":"vsftpd","link":"/hexo.github.io/tags/vsftpd/"},{"name":"功能需求与技术可行性分析","slug":"功能需求与技术可行性分析","link":"/hexo.github.io/tags/%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90/"},{"name":"需求文档","slug":"需求文档","link":"/hexo.github.io/tags/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/"},{"name":"项目知识点","slug":"项目知识点","link":"/hexo.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"项目前期构建","slug":"项目前期构建","link":"/hexo.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%89%8D%E6%9C%9F%E6%9E%84%E5%BB%BA/"}],"categories":[{"name":"Android学习","slug":"Android学习","link":"/hexo.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"},{"name":"Bitnami虚拟机","slug":"Bitnami虚拟机","link":"/hexo.github.io/categories/Bitnami%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Docker学习","slug":"Docker学习","link":"/hexo.github.io/categories/Docker%E5%AD%A6%E4%B9%A0/"},{"name":"GitBook学习","slug":"GitBook学习","link":"/hexo.github.io/categories/GitBook%E5%AD%A6%E4%B9%A0/"},{"name":"GitHub学习","slug":"GitHub学习","link":"/hexo.github.io/categories/GitHub%E5%AD%A6%E4%B9%A0/"},{"name":"Git学习","slug":"Git学习","link":"/hexo.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"},{"name":"Junit","slug":"Junit","link":"/hexo.github.io/categories/Junit/"},{"name":"IDEA","slug":"IDEA","link":"/hexo.github.io/categories/IDEA/"},{"name":"Kotlin学习","slug":"Kotlin学习","link":"/hexo.github.io/categories/Kotlin%E5%AD%A6%E4%B9%A0/"},{"name":"Linux入门","slug":"Linux入门","link":"/hexo.github.io/categories/Linux%E5%85%A5%E9%97%A8/"},{"name":"Maven和Gradle","slug":"Maven和Gradle","link":"/hexo.github.io/categories/Maven%E5%92%8CGradle/"},{"name":"MySQL8.0","slug":"MySQL8-0","link":"/hexo.github.io/categories/MySQL8-0/"},{"name":"Redis学习","slug":"Redis学习","link":"/hexo.github.io/categories/Redis%E5%AD%A6%E4%B9%A0/"},{"name":"Spring","slug":"Spring","link":"/hexo.github.io/categories/Spring/"},{"name":"java_web","slug":"java-web","link":"/hexo.github.io/categories/java-web/"},{"name":"企业级权限管理","slug":"企业级权限管理","link":"/hexo.github.io/categories/%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"},{"name":"企业级电商项目","slug":"企业级电商项目","link":"/hexo.github.io/categories/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/"},{"name":"项目实战","slug":"项目实战","link":"/hexo.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}]}